<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />

    
    
    
    
    <title>Граф: определения</title>
    <style>
        div.sitenav { display: flex; flex-direction: row; justify-content: flex-end; align-items: center; flex-grow: 0; }
        span.navlink { margin-left: 10px; }
        span.navlink-label { display: inline-block; min-width: 4em; }
        html {
                    font-family: Georgia, serif;
            
                    font-size: 18px;
            
                    line-height: 1.45;
            
            color: #1a1a1a;

            background-color: #fdfdfd;
        }
        body {
            margin: 0 auto;
            max-width: 64%;
            padding-left: 20px;
            padding-right: 50px;
            padding-top: 50px;
            padding-bottom: 50px;
            hyphens: auto;
            overflow-wrap: break-word;
            text-rendering: optimizeLegibility;
            font-kerning: normal;
        }
        @media (max-width: 600px) {
            body {
                font-size: 0.9rem;
                padding: 12px;
            }
            h1 {
                font-size: 1.8rem;
            }
        }
        @media print {
            html {
                background-color: white;
            }
            body {
                background-color: transparent;
                color: black;
                font-size: 16px;
            }
            p, h2, h3 {
                orphans: 3;
                widows: 3;
            }
            h2, h3, h4 {
                page-break-after: avoid;
            }
        }
        p {
            margin: 0.5rem 0;
        }
        a {
            color: #1a1a1a;
        }
        a:hover {
            color: #7bc99a;
        }
        a:visited {
            color: #1a1a1a;
        }
        img {
            max-width: 100%;
        }
        svg {
            height: auto;
            max-width: 100%;
        }

        h1 {
            padding-bottom: 3px;
            border-bottom: 1px solid black;
        }

        h1.title {
            font-size: 2.5rem;
            border: none;
        }
        h2.toc-title {
            border: none !important;
        }

        h1, h2, h3, h4 {
            margin: 1rem 0;
        }

        h1 {
            font-size: 2rem;
        }
        h2 {
            font-size: 1.8rem;
        }
        h3 {
            font-size: 1.6rem;
        }
        h4 {
            font-size: 1.4rem;
        }

        ol, ul {
            padding-left: 1.7rem;
            margin-top: 1rem;
        }
        li > ol, li > ul {
            margin-top: 0;
        }
        blockquote {
            margin: 1rem 0 1rem 1.7rem;
            padding-left: 1rem;
            border-left: 2px solid #e6e6e6;
            color: #606060;
        }


        code {
            font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
                font-size: 85%;
        /*    padding: 1rem 2rem;*/
            margin: 0;
            hyphens: manual;
        }
        pre {
            margin: 1rem 0;
                padding: 1rem 2rem;
            overflow: auto;
        }
        pre code {
        /*    padding: 1rem 2rem;*/
            overflow: visible;
            overflow-wrap: normal;
        }
        .sourceCode {
            background-color: transparent;
            overflow: visible;
        }
        div.sourceCode {
            border-radius: 5px;
            margin-left: 10px !important;
        }
        hr {
            background-color: #1a1a1a;
            border: none;
            height: 1px;
            margin: 1rem 0;
        }
        table {
            margin: 1rem 0;
            border-collapse: collapse;
            width: 100%;
            overflow-x: auto;
            display: block;
            font-variant-numeric: lining-nums tabular-nums;
        }
        table caption {
            margin-bottom: 0.75rem;
        }
        tbody {
            margin-top: 0.5rem;
            border-top: 1px solid #1a1a1a;
            border-bottom: 1px solid #1a1a1a;
        }
        th {
            border-top: 1px solid #1a1a1a;
            padding: 0.25rem 0.5rem 0.25rem 0.5rem;
        }
        td {
            padding: 0.125rem 0.5rem 0.25rem 0.5rem;
        }
        header {
            margin-bottom: 4rem;
            text-align: center;
        }

        #TOC li {
            list-style: none;
        }
        #TOC ul {
            padding-left: 1.3rem;
        }
        #TOC > ul {
            padding-left: 0;
        }
        #TOC a:not(:hover) {
            text-decoration: none;
        }

        code{white-space: pre-wrap;}
        span.smallcaps{font-variant: small-caps;}
        div.columns{display: flex; gap: min(4vw, 1.5em);}
        div.column{flex: auto; overflow-x: auto;}
        div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
        /* The extra [class] is a hack that increases specificity enough to
           override a similar rule in reveal.js */
        ul.task-list[class]{list-style: none;}
        ul.task-list li input[type="checkbox"] {
            font-size: inherit;
            width: 0.8rem;
            margin: 0 0.8rem 0.2rem -1.6rem;
            vertical-align: middle;
        }


    </style>

    
    <script src="https://kit.fontawesome.com/4b37446228.js" crossorigin="anonymous"></script>

    
            <script
            src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
            type="text/javascript"></script>
    </head>
<body>


<nav id="sitenav">
    <div class="sitenav">
        <span class="navlink">
                        <a href="решения-избранных-задач.html" accesskey="n" rel="previous"><i class="fa-solid fa-angle-left fa-sm" style="color: #363636;"></i></a>
                    </span>
        <span class="navlink">
                        <a href="index.html" accesskey="h" rel="top"><i class="fa-solid fa-book fa-sm" style="color: #363636;"></i></a>
                    </span>
        <span class="navlink">
                        <a href="топология-и-топологическое-пространство.html" accesskey="p" rel="next"><i class="fa-solid fa-angle-right fa-sm" style="color: #363636;"></i></a>
                    </span>
    </div>
</nav>



<h1 data-number="2" id="граф-определения">Граф: определения</h1>
<div id="definition-2">
<p><strong>Определение:</strong> <span
class="math inline">\(V^{(k)}\)</span> – это множество всех <span
class="math inline">\(k\)</span>-элементных подмножеств множества <span
class="math inline">\(V\)</span>.</p>
</div>
<div id="definition-3">
<p><strong>Определение:</strong> <em>Граф</em> – это тройка <span
class="math inline">\(\{E, V, \sigma\}\)</span>, где<br><span
class="math inline">\(E\)</span> – <em>множество ребер</em> (<span
class="math inline">\(e \in E\)</span> – <em>ребро</em>)<br><span
class="math inline">\(V\)</span> – <em>множество вершин</em> (<span
class="math inline">\(v \in V\)</span> – <em>вершина</em>)<br><span
class="math inline">\(\sigma: \,\,\,\, E \to V^{(1)} \cup
V^{(2)}\)</span> – <em>отношение инцидентности ребер и
вершин</em>.<br><br>Если <span class="math inline">\(\sigma(e) \in
V^{(1)}\)</span>, то <span class="math inline">\(e\)</span> –
<em>петля</em>.<br>Если <span class="math inline">\(\sigma(e) \in
V^{(2)} = \{u, v\}\)</span>, то вершина <span
class="math inline">\(u\)</span> <em>смежная</em> (<em>соседняя к</em>)
вершине <span class="math inline">\(v\)</span>.<br>Если <span
class="math inline">\(v \in \sigma(e)\)</span>, то вершина <span
class="math inline">\(v\)</span> <em>инцидентна</em> ребру <span
class="math inline">\(e\)</span>.<br>Если <span
class="math inline">\(\sigma(e) = \sigma(e’)\)</span>, то <span
class="math inline">\(e\)</span> и <span
class="math inline">\(e’\)</span> <em>кратные ребра</em>.<br></p>
</div>
<div id="definition-4">
<p><strong>Определение:</strong> Граф <em>простой</em>, если в нем нет
петель и кратных ребер.<br></p>
</div>
<p>Часто записывается <span class="math inline">\(G = \{E, V\}\)</span>,
вместо <span class="math inline">\(\{E, V, \sigma\}\)</span>.</p>
<div id="definition-5">
<p><strong>Определение:</strong> <em>Степень вершины</em> <span
class="math inline">\(v \in V\)</span> графа <span
class="math inline">\(G = \{E, V, \sigma\}\)</span> – это сумма
количества ребер инцидентных <span class="math inline">\(v\)</span> и не
являющихся петлями и удвоенного количества петель инцидентных <span
class="math inline">\(v\)</span>.</p>
</div>
<p>Обозначается: <span
class="math inline">\(\operatorname{deg}v\)</span>.</p>
<div id="statement-0">
<p><strong>Утверждение:</strong> <span
class="math display">\[\displaystyle \sum_{v \in V}\operatorname{deg}v =
2|E|\]</span></p>
<p><em>Доказательство:</em> <span
class="math inline">\(\,\,\,\,\blacksquare\)</span></p>
</div>
<div id="definition-6">
<p><strong>Определение:</strong> <em>Маршрут</em> (между вершинами <span
class="math inline">\(v_0\)</span> и <span
class="math inline">\(v_k\)</span>) в графе <span
class="math inline">\(G = \{E, V, \sigma\}\)</span> – это
последовательность <span class="math inline">\(v_0, e_1, v_1, e_2, v_2,
\ldots, e_k, v_k\)</span>, где <span class="math inline">\(v_i \in V
\,\,\,\,\forall i \in \{0, \ldots, k\}, \,\,\,\, e_i \in E
\,\,\,\,\forall i \in \{1, \ldots, k\}\)</span> и ребро <span
class="math inline">\(e_i\)</span> инцидентно вершинам <span
class="math inline">\(v_{i - 1}\)</span> и <span
class="math inline">\(v_i\)</span>.<br><br>Если в маршруте <span
class="math inline">\(\forall i \ne j \,\,\,\, e_i \ne e_j\)</span>, то
маршрут – это <em>цепь</em>.<br>Если в маршруте <span
class="math inline">\(v_0 = v_k\)</span>, то маршрут
<em>замкнутый</em>.<br>Замкнутая цепь – это <em>цикл</em>.<br>Если в
маршруте <span class="math inline">\(\forall i \ne j \ne 0 \ne k
\,\,\,\, v_i \ne v_j\)</span>, то маршрут – это
<em>путь</em>.<br>Замкнутый путь – это <em>простой цикл</em>.</p>
</div>
<div id="definition-7">
<p><strong>Определение:</strong> Граф <span class="math inline">\(G =
\{E, V , \sigma\}\)</span> <em>связный</em>, если <span
class="math inline">\(\forall u, v \in V\)</span> существует маршрут
между <span class="math inline">\(u\)</span> и <span
class="math inline">\(v\)</span>.</p>
</div>
<h2 data-number="2.1" id="эйлеров-граф">Эйлеров граф</h2>
<div id="definition-8">
<p><strong>Определение:</strong> <em>Эйлеров обход графа (эйлеров
цикл)</em> – это цикл, содержащий все вершины графа.</p>
</div>
<div id="definition-9">
<p><strong>Определение:</strong> Если в графе существует эйлеров цикл,
то граф – <em>эйлеров</em>.</p>
</div>
<div id="theorem-0">
<p><strong>Теорема:</strong> Граф эйлеров <span
class="math inline">\(\Leftrightarrow\)</span> граф связный и степени
всех вершин графа четны.</p>
<p><em>Доказательство:</em> <span
class="math display">\[\Rightarrow\]</span></p>
</div>
<p>Граф эйлеров, значит существует цикл, содержащий все вершины графа.
Идя по этому циклу, в каждую вершину нужно зайти и выйти, то есть
степень любой вершины четна.</p>
<p><span class="math display">\[\Leftarrow\]</span></p>
<p>Степени всех вершин четны, граф конечный и связный. Начнем в
какой-нибудь вершине и будем строить цикл, выбирая каждый раз следующей
непосещенную вершину, так как граф конечный этот процесс завершится и
будет получен искомый цикл <span
class="math inline">\(\,\,\,\,\blacksquare\)</span> (Плохо)</p>
<h2 data-number="2.2" id="гамильтонов-граф">Гамильтонов граф</h2>
<div id="definition-10">
<p><strong>Определение:</strong> <em>Гамильтонов цикл</em> – это простой
цикл, проходящий через все вершины графа.</p>
</div>
<div id="definition-11">
<p><strong>Определение:</strong> Граф <em>гамильтонов</em>, если в нем
есть гамильтонов цикл.</p>
</div>
<div id="statement-1">
<p><strong>Утверждение:</strong> Пусть <span class="math inline">\(G =
\{E, V, \sigma\}\)</span> гамильтонов граф. Тогда</p>
<ol type="1">
<li><span class="math inline">\(G\)</span> связный.</li>
<li>Если <span class="math inline">\(|V| &gt; 1\)</span>, то в <span
class="math inline">\(G\)</span> нет петель.</li>
<li>Если <span class="math inline">\(|V| &gt; 2\)</span>, то в <span
class="math inline">\(G\)</span> нет кратных ребер.</li>
</ol>
<p><em>Доказательство:</em></p>
</div>
<ol type="1">
<li>Гамильтонов цикл проходит через все вершины.</li>
<li>Гамильтонов цикл проходит через вершину ровно один раз.</li>
<li>см 2. <span class="math inline">\(\,\,\,\,\blacksquare\)</span></li>
</ol>
<p>То есть для определения гамильтоновости графа достаточно
рассматривать простые графы.</p>
<div id="theorem-1">
<p><strong>Теорема:</strong> (Дирака) Пусть <span
class="math inline">\(G = \{E, V, \sigma\}\)</span> – простой граф,
<span class="math inline">\(|V| = n, \,\,\,\, n \ge 3, \,\,\,\, \forall
v \,\,\,\, \operatorname{deg}v \ge \frac{n}{2}\)</span>. Тогда <span
class="math inline">\(G\)</span> гамильтонов.</p>
<p><em>Доказательство:</em></p>
</div>
<p>Идея: Построить самый длинный путь в графе <span
class="math inline">\(G\)</span>. Пусть его длина <span
class="math inline">\(l\)</span>. Доказать, что можно получить цикл
длины <span class="math inline">\(l + 1\)</span>. Предположить, что
полученный цикл не гамильтонов. Прийти к противоречию. Всё! <img
src="img/gamilton.png" /></p>
<p>Пусть <span class="math inline">\(\gamma = v_0v_1\ldots
v_{l-1}v_l\)</span> самый длинный путь в графе. Докажем существование
цикла длины <span class="math inline">\(l + 1\)</span>. Если <span
class="math inline">\(v_0\)</span> и <span
class="math inline">\(v_l\)</span> смежны, то таким циклом является
последовательность <span class="math inline">\(v_0v_1\ldots
v_{l-1}v_lv_0\)</span>. Иначе хотим найти вершину <span
class="math inline">\(v_k \in \gamma\)</span>, такую чтобы следующая за
ней в пути вершина была смежна с <span
class="math inline">\(v_0\)</span>, а сама <span
class="math inline">\(v_k\)</span> была смежна с <span
class="math inline">\(v_l\)</span> (см. рисунок). Если доказать
существование такой вершины, то искомым циклом будет <span
class="math inline">\(v_0\ldots v_kv_l\ldots v_{k + 1}v_0\)</span> (на
рисунке черный путь + оранжевое ребро – это <span
class="math inline">\(\gamma\)</span>, а черные ребра + зеленые – это
искомый цикл).</p>
<p>Рассмотрим множества: <span class="math inline">\(X = \{v_i: \,\,\,\,
v_iv_l \in E\}\)</span> и <span class="math inline">\(Y = \{v_i:
\,\,\,\, v_{i + 1}v_0 \in E\}\)</span>. Все вершины смежные с <span
class="math inline">\(v_0\)</span> принадлежат пути, потому что иначе
можно было бы увелечить длину пути. <span class="math inline">\(|X| =
\operatorname{deg}v_l \ge \frac{n}{2}, \,\,\,\, |Y| =
\operatorname{deg}v_0 \ge \frac{n}{2} \Rightarrow |X| + |Y| \ge
n\)</span>. Пусть <span class="math inline">\(X \cap Y =
\varnothing\)</span>. Тогда <span class="math inline">\(|X \cup Y| = |X|
+ |Y| \ge n\)</span>, но вершина <span class="math inline">\(v_l \not
\in X\)</span> и <span class="math inline">\(v_l \not \in Y
\Rightarrow\)</span> в графе больше <span
class="math inline">\(n\)</span> вершин. Противоречие, а значит <span
class="math inline">\(\exists v_k: \,\,\,\, v_k \in X \cap
Y\)</span>.</p>
<p><img src="img/gamilton2.png" /></p>
<p>Докажем, что полученный цикл <span class="math inline">\(C\)</span>
гамильтонов. Предположим обратное, тогда <span
class="math inline">\(\exists v \in V: \,\,\,\, v \not\in
\gamma\)</span>. Пусть <span class="math inline">\(v\)</span> смежна с
вершиной <span class="math inline">\(v_s\)</span> из цикла <span
class="math inline">\(C\)</span>. Тогда выбросив любое из смежных с
<span class="math inline">\(v_s\)</span> ребер, принадлежащих <span
class="math inline">\(C\)</span> получим путь длины <span
class="math inline">\(l + 1\)</span>. Противоречие. Значит <span
class="math inline">\(v\)</span> не смежна ни с одной вершиной <span
class="math inline">\(C\)</span>. Вершин смежных с <span
class="math inline">\(v \ge \frac{n}{2}\)</span>. Вершин смежных с <span
class="math inline">\(v_0 \ge \frac{n}{2}\)</span> и все они принадлежат
<span class="math inline">\(C\)</span>. Значит в графе больше, чем <span
class="math inline">\(n\)</span> вершин. Противоречие. Следовательно,
<span class="math inline">\(C\)</span> гамильтонов цикл <span
class="math inline">\(\,\,\,\,\blacksquare\)</span></p>
<h2 data-number="2.3" id="подграфы">Подграфы</h2>
<div id="definition-12">
<p><strong>Определение:</strong> <span class="math inline">\(H = (V_H,
E_H, \sigma_H)\)</span> <em>подграф</em> графа <span
class="math inline">\(G = (V_G, E_G, \sigma_G)\)</span>, если <span
class="math inline">\(V_H \subset V_G, \,\,\,\, E_H \subset E_G,
\,\,\,\, \sigma_H = \sigma_G |_{E_H}\)</span>.</p>
</div>
<div id="definition-13">
<p><strong>Определение:</strong> Подграф <em>остовный</em>, если
содержит все вершины исходного.</p>
</div>
<div id="definition-14">
<p><strong>Определение:</strong> Пусть <span class="math inline">\(M
\subset V, \,\,\,\, G = (V, E, \sigma)\)</span>. Обозначим <span
class="math inline">\(G(M) = (M, E_M = \{\sigma^{-1}(M^{(1)} \cup
M^{(2)}), \sigma |_{E_M}\})\)</span>.</p>
</div>
<div id="statement-2">
<p><strong>Утверждение:</strong> Пусть <span class="math inline">\(M
\subset V, \,\,\,\, G = (V, E, \sigma)\)</span>. Тогда <span
class="math inline">\(G(M)\)</span> – подграф <span
class="math inline">\(G\)</span>.</p>
<p><em>Доказательство:</em> очев <span
class="math inline">\(\,\,\,\,\blacksquare\)</span></p>
</div>
<div id="definition-15">
<p><strong>Определение:</strong> Пусть <span class="math inline">\(G =
(V, E, \sigma), \,\,\,\, w \in W, \,\,\,\, v \in V\)</span>.</p>
</div>
<p><span class="math inline">\(w \sim v\)</span>
(<em>эквивалентно</em>), если существует маршрут из <span
class="math inline">\(w\)</span> в <span
class="math inline">\(v\)</span>.</p>
<div id="statement-3">
<p><strong>Утверждение:</strong> Введенная выше “<span
class="math inline">\(\sim\)</span>” является отношением эквивалентности
на множестве вершин графа.</p>
<p><em>Доказательство:</em> <span
class="math inline">\(\,\,\,\,\blacksquare\)</span></p>
</div>
<div id="definition-16">
<p><strong>Определение:</strong> Класс эквивалентности вершины <span
class="math inline">\(v\)</span> графа <span
class="math inline">\(G\)</span> обозначается <span
class="math inline">\([v]\)</span>.</p>
</div>
<div id="definition-17">
<p><strong>Определение:</strong> <em>Компонента связности</em> вершины
<span class="math inline">\(v\)</span> графа <span
class="math inline">\(G\)</span> – это максимальный по включению
подграф, содержащий <span class="math inline">\(v\)</span>.</p>
</div>
<div id="statement-4">
<p><strong>Утверждение:</strong> <span
class="math inline">\(G([v])\)</span> – это компонента связности вершины
<span class="math inline">\(v\)</span>.</p>
<h3 data-number="2.3.1" id="деревья">Деревья</h3>
<div id="definition-18">
<p><strong>Определение:</strong> <em>Дерево</em> – это связный граф без
циклов.</p>
</div>
<p><strong>Теорема:</strong><a name="theorem-0"></a> Пусть <span
class="math inline">\(G = \{V, E\}\)</span> – граф, <span
class="math inline">\(|V| = n, \,\,\,\, |E| = m\)</span>. Следующие
утверждения эквивалентны.</p>
<ol type="1">
<li><span class="math inline">\(G\)</span> – дерево.</li>
<li><span class="math inline">\(G\)</span> связный и <span
class="math inline">\(n = m + 1\)</span>.</li>
<li><span class="math inline">\(G\)</span> не содержит циклов и <span
class="math inline">\(n = m + 1\)</span>.</li>
<li>В <span class="math inline">\(G\)</span> между любыми двумя
вершинами существует единственный маршрут.</li>
<li><span class="math inline">\(G\)</span> не содержит циклов и в графе,
содержащем ребро между двумя несмежными вершинами <span
class="math inline">\(G\)</span>, существует ровно один цикл.</li>
</ol>
<p><em>Доказательство:</em></p>
</div>
<p><span class="math display">\[1 \Rightarrow 2\]</span> Докажем
индукцией по количеству вершин. База: <span class="math inline">\(n =
1\)</span> тогда ребер <span class="math inline">\(0\)</span>, так как
нет петель, то есть <span class="math inline">\(n = 1 = 0 + 1\)</span>
что и требовалось. Пусть <span class="math inline">\(n \ge 2\)</span> и
для деревьев с меньшим, чем <span class="math inline">\(n\)</span>
числом вершин верно <span class="math inline">\(n = m + 1\)</span>.
Тогда возьмем произвольное ребро <span
class="math inline">\(e\)</span>(множество ребер непусто, так как граф
связный) и рассмотрим <span class="math inline">\(G\setminus
e\)</span>.</p>
<div id="lemma-0">
<p><strong>Лемма:</strong> Пусть <span class="math inline">\(G\)</span>
— дерево, <span class="math inline">\(e\)</span> – произвольное ребро в
нем. Тогда граф <span class="math inline">\(G\)</span> без ребра <span
class="math inline">\(e\)</span> содержит <span
class="math inline">\(2\)</span> компоненты связности, каждая из которых
– дерево.</p>
<p><em>Доказательство:</em> Пусть <span class="math inline">\(e\)</span>
соединяет <span class="math inline">\(v_1\)</span> и <span
class="math inline">\(v_2\)</span>. <span
class="math inline">\(G\)</span> – связный, значит, убрав одно ребро
получим <span class="math inline">\(1\)</span> или <span
class="math inline">\(2\)</span> компоненты связности. Если получим одну
компоненту, то существует маршрут из <span
class="math inline">\(v_1\)</span> в <span
class="math inline">\(v_2\)</span>. Следовательно, в <span
class="math inline">\(G\)</span> был цикл. Противоречие. Получили две
компоненты связности, каждая из которых не содержит циклов, так как
циклов нет в <span class="math inline">\(G
\,\,\,\,\blacksquare\)</span></p>
</div>
<p>Для <span class="math inline">\(2\)</span>-ух полученных компонент
связности – деревьев верно предположение индукции. Пусть в первом и
втором деревьях <span class="math inline">\(n_1, n_2, m_1, m_2\)</span>
вершин и ребер соответственно. Тогда <span class="math inline">\(n_1 =
m_1 + 1, \,\,\,\, n_2 = m_2 + 1\)</span>. <span class="math inline">\(n
= n_1 + n_2 = m_1 + 1 + m_2 + 1 = (m_1 + m_2 + 1) + 1
\,\,\,\,\blacksquare\)</span> (в <span class="math inline">\(G\)</span>
<span class="math inline">\(m_1 + m_2 + 1\)</span> – ребер)</p>
<p><span class="math display">\[2 \Rightarrow 3\]</span></p>
<p>Пусть <span class="math inline">\(G\)</span> содержит цикл.</p>
<div id="lemma-1">
<p><strong>Лемма:</strong> Пусть простой граф <span
class="math inline">\(G\)</span> содержит <span
class="math inline">\(n\)</span> вершин, <span
class="math inline">\(m\)</span> ребер и <span
class="math inline">\(k\)</span> компонент связности. Тогда <span
class="math inline">\(n - m \le k\)</span>.</p>
<p><em>Доказательство:</em> Докажем индукцией по количеству ребер. Для
<span class="math inline">\(m = 0 \,\,\,\, n = k\)</span>, что и
требовалось. Пусть ребер <span class="math inline">\(m \ge 1\)</span> и
для всех графов с меньшим числом вершин утверждение выполнено. Тогда
выберем произвольное ребро <span class="math inline">\(e\)</span> и
рассмотрим граф без него. Убрав ребро, получим либо <span
class="math inline">\(k\)</span> компонент связности либо <span
class="math inline">\(k + 1\)</span>. Для графа <span
class="math inline">\(G \\ e\)</span> верно <span
class="math inline">\(n’ - m’ \le k’\)</span>, <span
class="math inline">\(m’, \,\,\,\, n’, \,\,\,\, k’\)</span> – количество
ребер, вершин и компонент связности <span
class="math inline">\(G\setminus e \,\,\,\,\blacksquare\)</span></p>
</div>
<p>Рассмотри граф <span class="math inline">\(G\)</span> без
произвольного ребра <span class="math inline">\(e\)</span>, входящего в
цикл. <span class="math inline">\(G\setminus e\)</span> связный, так как
<span class="math inline">\(e\)</span> входило в цикл. То есть в <span
class="math inline">\(G\)</span> - <span
class="math inline">\(n\)</span> вершин и <span class="math inline">\(n
- 2\)</span> ребер, что противоречит <a
href="граф-определения.html#lemma-1">лемме</a> <span
class="math inline">\(\,\,\,\,\blacksquare\)</span></p>
<p><span class="math display">\[3 \Rightarrow 4\]</span> Единственность
маршрута при его существовании очевидна. Маршрут существует между любыми
двумя вершинами <span class="math inline">\(G\)</span>, так как,
предположив, что в <span class="math inline">\(G\)</span> - <span
class="math inline">\(k\)</span> компонент связности(которые не содержат
циклов, а следовательно деревья) получим, что <span
class="math inline">\(n =\)</span> сумма количества вершин в каждой
компоненте = сумма количества ребер в каждой компоненте + <span
class="math inline">\(k\)</span>(по <span class="math inline">\(1
\Rightarrow 2\)</span>) <span class="math inline">\(= m + 1
\,\,\,\,\blacksquare\)</span></p>
<p><span class="math display">\[4 \Rightarrow 5\]</span></p>
<p>Если в <span class="math inline">\(G\)</span> есть цикл, то
нарушается условие о единственности маршрута. Добавив ребро, получим
цикл, так как маршрут существует между любыми двумя вершинами. Если
получим больше одного цикла, то они оба содержат добавленное ребро, а
следовательно существует цикл в <span class="math inline">\(G
\,\,\,\,\blacksquare\)</span></p>
<p><span class="math display">\[5 \Rightarrow 1\]</span></p>
<p><span class="math inline">\(G\)</span> – связный, так как для каждой
пары вершин существует маршрут между ними <span
class="math inline">\(\,\,\,\,\blacksquare\)</span></p>


<nav id="sitenav">
    <div class="sitenav">
        <span class="navlink">
                        <a href="решения-избранных-задач.html" accesskey="n" rel="previous"><i class="fa-solid fa-angle-left fa-sm" style="color: #363636;"></i></a>
                    </span>
        <span class="navlink">
                        <a href="index.html" accesskey="h" rel="top"><i class="fa-solid fa-book fa-sm" style="color: #363636;"></i></a>
                    </span>
        <span class="navlink">
                        <a href="топология-и-топологическое-пространство.html" accesskey="p" rel="next"><i class="fa-solid fa-angle-right fa-sm" style="color: #363636;"></i></a>
                    </span>
    </div>
</nav>

</body>
</html>
