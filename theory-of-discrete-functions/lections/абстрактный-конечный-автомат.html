<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />

    
    
    
    
    <title>Абстрактный конечный автомат</title>
    <style>
        div.sitenav { display: flex; flex-direction: row; justify-content: flex-end; align-items: center; flex-grow: 0; }
        span.navlink { margin-left: 10px; }
        span.navlink-label { display: inline-block; min-width: 4em; }
        html {
                    font-family: Georgia, serif;
            
                    font-size: 18px;
            
                    line-height: 1.45;
            
            color: #1a1a1a;

            background-color: #fdfdfd;
        }
        body {
            margin: 0 auto;
            max-width: 64%;
            padding-left: 20px;
            padding-right: 50px;
            padding-top: 50px;
            padding-bottom: 50px;
            hyphens: auto;
            overflow-wrap: break-word;
            text-rendering: optimizeLegibility;
            font-kerning: normal;
        }
        @media (max-width: 600px) {
            body {
                font-size: 0.9rem;
                padding: 12px;
            }
            h1 {
                font-size: 1.8rem;
            }
        }
        @media print {
            html {
                background-color: white;
            }
            body {
                background-color: transparent;
                color: black;
                font-size: 16px;
            }
            p, h2, h3 {
                orphans: 3;
                widows: 3;
            }
            h2, h3, h4 {
                page-break-after: avoid;
            }
        }
        p {
            margin: 0.5rem 0;
        }
        a {
            color: #1a1a1a;
        }
        a:hover {
            color: #7bc99a;
        }
        a:visited {
            color: #1a1a1a;
        }
        img {
            max-width: 100%;
        }
        svg {
            height: auto;
            max-width: 100%;
        }

        h1 {
            padding-bottom: 3px;
            border-bottom: 1px solid black;
        }

        h1.title {
            font-size: 2.5rem;
            border: none;
        }
        h2.toc-title {
            border: none !important;
        }

        h1, h2, h3, h4 {
            margin: 1rem 0;
        }

        h1 {
            font-size: 2rem;
        }
        h2 {
            font-size: 1.8rem;
        }
        h3 {
            font-size: 1.6rem;
        }
        h4 {
            font-size: 1.4rem;
        }

        ol, ul {
            padding-left: 1.7rem;
            margin-top: 1rem;
        }
        li > ol, li > ul {
            margin-top: 0;
        }
        blockquote {
            margin: 1rem 0 1rem 1.7rem;
            padding-left: 1rem;
            border-left: 2px solid #e6e6e6;
            color: #606060;
        }


        code {
            font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
                font-size: 85%;
        /*    padding: 1rem 2rem;*/
            margin: 0;
            hyphens: manual;
        }
        pre {
            margin: 1rem 0;
                padding: 1rem 2rem;
            overflow: auto;
        }
        pre code {
        /*    padding: 1rem 2rem;*/
            overflow: visible;
            overflow-wrap: normal;
        }
        .sourceCode {
            background-color: transparent;
            overflow: visible;
        }
        div.sourceCode {
            border-radius: 5px;
            margin-left: 10px !important;
        }
        hr {
            background-color: #1a1a1a;
            border: none;
            height: 1px;
            margin: 1rem 0;
        }
        table {
            margin: 1rem 0;
            border-collapse: collapse;
            width: 100%;
            overflow-x: auto;
            display: block;
            font-variant-numeric: lining-nums tabular-nums;
        }
        table caption {
            margin-bottom: 0.75rem;
        }
        tbody {
            margin-top: 0.5rem;
            border-top: 1px solid #1a1a1a;
            border-bottom: 1px solid #1a1a1a;
        }
        th {
            border-top: 1px solid #1a1a1a;
            padding: 0.25rem 0.5rem 0.25rem 0.5rem;
        }
        td {
            padding: 0.125rem 0.5rem 0.25rem 0.5rem;
        }
        header {
            margin-bottom: 4rem;
            text-align: center;
        }

        #TOC li {
            list-style: none;
        }
        #TOC ul {
            padding-left: 1.3rem;
        }
        #TOC > ul {
            padding-left: 0;
        }
        #TOC a:not(:hover) {
            text-decoration: none;
        }

        code{white-space: pre-wrap;}
        span.smallcaps{font-variant: small-caps;}
        div.columns{display: flex; gap: min(4vw, 1.5em);}
        div.column{flex: auto; overflow-x: auto;}
        div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
        /* The extra [class] is a hack that increases specificity enough to
           override a similar rule in reveal.js */
        ul.task-list[class]{list-style: none;}
        ul.task-list li input[type="checkbox"] {
            font-size: inherit;
            width: 0.8rem;
            margin: 0 0.8rem 0.2rem -1.6rem;
            vertical-align: middle;
        }


    </style>

    
    <script src="https://kit.fontawesome.com/4b37446228.js" crossorigin="anonymous"></script>

    
            <script
            src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
            type="text/javascript"></script>
    </head>
<body>


<nav id="sitenav">
    <div class="sitenav">
        <span class="navlink">
                        <a href="функции-k-значной-логики.html" accesskey="n" rel="previous"><i class="fa-solid fa-angle-left fa-sm" style="color: #363636;"></i></a>
                    </span>
        <span class="navlink">
                        <a href="index.html" accesskey="h" rel="top"><i class="fa-solid fa-book fa-sm" style="color: #363636;"></i></a>
                    </span>
        <span class="navlink">
                    </span>
    </div>
</nav>



<h1 data-number="4" id="абстрактный-конечный-автомат">Абстрактный
конечный автомат</h1>
<style>
img#inv {
    display: none;
}
    /********** Range Input Styles **********/
/*Range Reset*/
input[type="range"] {
   -webkit-appearance: none;
    appearance: none;
    background: transparent;
    cursor: pointer;
    width: 90%;
    margin-bottom: 3rem;
}

/* Removes default focus */
input[type="range"]:focus {
  outline: none;
}

/***** Chrome, Safari, Opera and Edge Chromium styles *****/
/* slider track */
input[type="range"]::-webkit-slider-runnable-track {
   background-color: #55C1A7;
   border-radius: 0.125rem;
   height: 0.25rem;  
}

/* slider thumb */
input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none; /* Override default look */
   appearance: none;

   /*custom styles*/
   background-color: #55C1A7;
   margin-top: -0.875rem;
   height: 2rem;
   width: 2rem;
   border-radius: 1rem;
}

/******** Firefox styles ********/
/* slider thumb */
input[type="range"]::-moz-range-thumb {
   border: none; /*Removes extra border that FF applies*/
   border-radius: 0; /*Removes default border-radius that FF applies*/

   /*custom styles*/
   background-color: #55C1A7;
   margin-top: -1rem;
   height: 2rem;
   width: 2rem;
   border-radius: 1rem;
}

button {
    -webkit-appearance: none;
    appearance: none;
    background: transparent;
    border: none;
}
</style>
<h2 data-number="4.1" id="способы-задания">Способы задания</h2>
<center>
<button id="state_button" class="icon-button">
<img id="iconImage" src="img/red_heart.png" alt="Icon">
</button>
</center>
<center>
<canvas id="main-canvas">
</canvas>
</center>
<center>
<div id="slider-div">
<input type="range" id="slider" min="1" max="20" value="1">
</div>
</center>
<p>Пускай есть машина, которая получает <span
class="math inline">\(a\)</span> на вход и выдает <span
class="math inline">\(b\)</span>. Скучно. Пускай теперь есть много машин
(ну или разные состояния одной) и известно в какой момент времени какая
машина работает (в каком состоянии находится машина), причем, что очень
важно, состояние в следующий момент времени определяется состоянием в
текущий и (возможно) входом <span class="math inline">\(a\)</span>
(слайдер отвечает за время).</p>
<div id="definition-56">
<p><strong>Определение:</strong> <em>(Конечный абстрактный
детерминированный) автомат</em> – это <span class="math inline">\((A, Q,
B, \varphi, \psi)\)</span>, где<br><br> <span
class="math inline">\(A\)</span> – <em>алфавит(множество)
входов</em>.<br><br> <span class="math inline">\(Q\)</span> –
<em>алфавит(множество) состояний</em>.<br><br> <span
class="math inline">\(B\)</span> – <em>алфавит(множество)
выходов</em>.<br><br>Множества <span class="math inline">\(A, Q,
B\)</span> – конечны.<br><br> <span class="math inline">\(\varphi:
Q\times A \to Q\)</span> – <em>функция переходов</em>.<br><br> <span
class="math inline">\(\psi: Q \times A \to B\)</span> – <em>функция
выходов</em>.<br><br></p>
</div>
<center>
<strong>Алфавит входов</strong>
</center>
<center>
<canvas id="heart-table-canvas">
</canvas>
</center>
<center>
<strong>Алфавит состояний</strong>
</center>
<center>
<canvas id="table-canvas">
</canvas>
</center>
<center>
<strong>Алфавит выходов</strong>
</center>
<center>
<canvas id="diam-table-canvas">
</canvas>
</center>
<div id="definition-57">
<p><strong>Определение:</strong> Пусть <span class="math inline">\((A,
Q, B, \varphi, \psi)\)</span> – автомат. Если <span
class="math inline">\(\varphi\)</span> зависит от <span
class="math inline">\(a \in A\)</span> фиктивно, то <span
class="math inline">\((A, Q, B, \varphi, \psi)\)</span> – <em>автомат
Мура</em>.</p>
</div>
<div id="definition-58">
<p><strong>Определение:</strong> Пусть <span class="math inline">\((A,
Q, B, \varphi, \psi)\)</span> – автомат. Если <span
class="math inline">\(A = A_1 \times \ldots \times A_m\)</span>, то
<span class="math inline">\((A, Q, B, \varphi, \psi)\)</span>
<em>имеет</em> <span class="math inline">\(m\)</span>
<em>входов</em>.</p>
</div>
<div id="definition-59">
<p><strong>Определение:</strong> Пусть <span class="math inline">\((A,
Q, B, \varphi, \psi)\)</span> – автомат. Если <span
class="math inline">\(B = B_1 \times \ldots \times B_m\)</span>, то
<span class="math inline">\((A, Q, B, \varphi, \psi)\)</span>
<em>имеет</em> <span class="math inline">\(m\)</span>
<em>выходов</em>.</p>
</div>
<h3 data-number="4.1.1" id="диаграмма-мура">Диаграмма Мура</h3>
<center>
<canvas id="diagram-canvas">
</canvas>
</center>
<h2 data-number="4.2"
id="вспомогательные-функции-для-автомата">Вспомогательные функции для
автомата</h2>
<div id="definition-60">
<p><strong>Определение:</strong> Пусть <span class="math inline">\((A,
Q, B, \varphi, \psi)\)</span> – автомат.</p>
<p>Слова в алфавите <span class="math inline">\(A\)</span> – <em>входные
слова</em>.</p>
<p>Слова в алфавите <span class="math inline">\(B\)</span> –
<em>выходные слова</em>.</p>
<p>Пусть <span class="math inline">\(\alpha\)</span> – слово. <span
class="math inline">\(A\)</span> – алфавит.</p>
<p><strong>Обозначения:</strong></p>
<p><span class="math inline">\(|\alpha|\)</span> – длина слова.</p>
<p><span class="math inline">\([\alpha]_l\)</span> – первые <span
class="math inline">\(l\)</span> букв слова <span
class="math inline">\(\alpha\)</span>.</p>
<p><span class="math inline">\(\Lambda\)</span> – пустое слово.</p>
<p><span class="math inline">\(A^{*}\)</span> – множество всех слов в
алфавите <span class="math inline">\(A\)</span>.</p>
<p><span class="math inline">\(\alpha^k\)</span> – это слово,
составленное из записанного <span class="math inline">\(k\)</span> раз
слова <span class="math inline">\(\alpha\)</span>.</p>
</div>
<h3 data-number="4.2.1"
id="доопределение-функций-входа-и-состояний">Доопределение функций входа
и состояний</h3>
<p>Пусть <span class="math inline">\((A, Q, B, \varphi, \psi)\)</span> –
автомат. <span class="math inline">\(q \in Q\)</span>, <span
class="math inline">\(a \in A\)</span>, <span
class="math inline">\(\alpha\)</span> – слово в алфавите <span
class="math inline">\(A\)</span>. Доопределим функции <span
class="math inline">\(\varphi\)</span> и <span
class="math inline">\(\psi\)</span>, так чтобы они могли принимать на
вход целые слова.</p>
<p><span class="math inline">\(\begin{array}{c}
    \varphi(q, \Lambda) = q\\
    \varphi(q, \alpha a) = \varphi(\varphi(q, \alpha), a)
\end{array}\)</span></p>
<p><span class="math inline">\(\psi(q, \alpha a) = \psi(\varphi(q,
\alpha), a)\)</span> (Только непустое входное слово, так как для выхода
нужен вход)</p>
<div id="statement-26">
<p><strong>Утверждение:</strong><br />
<span class="math display">\[\varphi(q, \alpha_1 \alpha_2) =
\varphi(\varphi(q, \alpha_1), \alpha_2)\]</span> <span
class="math display">\[\psi(q, \alpha_1 \alpha_2) = \psi(\varphi(q,
\alpha_1), \alpha_2)\]</span></p>
<p><em>Доказательство:</em> индукция <span
class="math inline">\(\,\,\,\,\blacksquare\)</span></p>
</div>
<div id="definition-61">
<p><strong>Определение:</strong> Пусть <span class="math inline">\((A,
Q, B, \varphi, \psi)\)</span> – автомат. <span class="math inline">\(q
\in Q\)</span>, <span class="math inline">\(\alpha\)</span> – слово в
алфавите <span class="math inline">\(A\)</span>.</p>
<p><span class="math inline">\(\overline{\varphi}(q, \alpha) =
\varphi(q, [\alpha]_0)\varphi(q, [\alpha]_1)\ldots \varphi(q,
\alpha)\)</span> – <em>слово состояний</em>.</p>
<p><span class="math inline">\(\overline{\psi}(q, \alpha) = \psi(q,
[\alpha]_0)\psi(q, [\alpha]_1)\ldots \psi(q, \alpha)\)</span> –
<em>слово выходов</em>.</p>
</div>
<div id="definition-62">
<p><strong>Определение:</strong> Пусть <span class="math inline">\((A,
Q, B, \varphi, \psi)\)</span> – автомат. Зафиксируем <span
class="math inline">\(q_1 \in Q\)</span>. Тогда <span
class="math inline">\(\psi: A^{*} \to B^{*}\)</span>. <span
class="math inline">\(V_{q_1} = (A, Q, B, \varphi, \psi, q_1)\)</span> –
<em>инициальный конечный автомат</em>.</p>
<p>Отображение <span class="math inline">\(f(\alpha) =
\overline{\psi}(q_1, \alpha)\)</span> –
<em>ограниченно-детерминированная функция</em>.</p>
</div>
<h3 data-number="4.2.2"
id="канонические-уравнения-инициального-автомата">Канонические уравнения
инициального автомата</h3>
<div id="definition-63">
<p><strong>Определение:</strong> Пусть <span
class="math inline">\(V_{q_1} = (A, Q, B, \varphi, \psi, q_1)\)</span> –
инициальный атомат. <span class="math inline">\(\alpha\)</span> – слово
в алфавите <span class="math inline">\(A\)</span>.</p>
<p><span class="math inline">\(\mathcal{Q} = \overline{\varphi}(q_1,
\alpha)\)</span> – слово состояний.</p>
<p><span class="math inline">\(\beta = \overline{\psi}(q_1,
\alpha)\)</span> – слово выходов.</p>
<p><span class="math inline">\(\begin{cases}
  \mathcal{Q}(1) = q_1\\
  \mathcal{Q}(t + 1) = \varphi(\mathcal{Q}(t), \alpha(t))\\
  \beta(t) = \psi(\mathcal{Q}(t), \alpha(t))
\end{cases}\)</span> – <em>канонические уравнения инициального
автомата</em>.</p>
</div>
<div id="statement-27">
<p><strong>Утверждение:</strong></p>
<p><span class="math display">\[\overline{\psi}(q, \alpha_1 \alpha_2) =
\overline{\psi}(q, \alpha_1)\overline{\psi}(\varphi(q, \alpha_1),
\alpha_2)\]</span></p>
<p><em>Доказательство:</em> индукция <span
class="math inline">\(\,\,\,\,\blacksquare\)</span></p>
</div>
<h2 data-number="4.3" id="автоматы-в-p_2">Автоматы в <span
class="math inline">\(P_2\)</span></h2>
<p>Пусть <span class="math inline">\(A = \underbrace{E_2 \times \ldots
\times E_2}_{m}\)</span>,</p>
<p><span class="math inline">\(Q = \underbrace{E_2 \times \ldots \times
E_2}_{n}\)</span>,</p>
<p><span class="math inline">\(B = \underbrace{E_2 \times \ldots \times
E_2}_{p}\)</span>.</p>
<p>Пусть <span class="math inline">\(\alpha\)</span> – слово в <span
class="math inline">\(A\)</span>. Тогда <span
class="math inline">\(\alpha\)</span> можно записать, как <span
class="math inline">\(\alpha(t) = (a_1(t), \ldots, a_m(t))\)</span>.</p>
<p><span class="math inline">\(\mathcal{Q}(t) = (q_1(t), \ldots,
q_n(t))\)</span>.</p>
<p><span class="math inline">\(\beta(t) = (b_1(t), \ldots,
b_p(t))\)</span>.</p>
<p><span class="math inline">\(q_1 = (q_{11}, \ldots,
q_{1n})\)</span>.</p>
<p>Запишем канонические уравнения<a name="canon-p2"></a>:</p>
<p><span class="math display">\[\begin{cases}
  q_i(1) = q_{1i}\\
  q_i(t + 1) = \varphi_i(q_1(t), \ldots, q_n(t), a_1(t), \ldots,
a_m(t))\\
  b_j(t) = \psi_j(q_1(t), \ldots, q_n(t), a_1(t), \ldots, a_m(t))
\end{cases}\]</span></p>
<h2 data-number="4.4" id="автоматы-и-бесконечные-слова">Автоматы и
бесконечные слова</h2>
<div id="definition-64">
<p><strong>Определение:</strong> Пусть <span
class="math inline">\(A\)</span> – алфавит. Пусть дано отображение <span
class="math inline">\(\alpha: \mathbb{N} \to A\)</span>. <span
class="math inline">\(\alpha(1)\alpha(3)\ldots\)</span> –
<em>бесконечное слово</em>.</p>
<p>Множество всех бесконечных слов обозначается <span
class="math inline">\(A^{\infty}\)</span>.</p>
</div>
<p>Пусть <span class="math inline">\(V_q = (A, Q, B, \varphi, \psi,
q)\)</span> – инициальный автомат. <span
class="math inline">\(\alpha\)</span> – бесконечное слово в <span
class="math inline">\(A\)</span>.</p>
<p><span class="math inline">\(\beta = \overline{\psi}(q, \alpha):
\mathbb{N} \to B\)</span></p>
<p><span class="math inline">\(\beta(i) = \psi(q, \alpha(1)\ldots
\alpha(i))\)</span>.</p>
<div id="definition-65">
<p><strong>Определение:</strong> Пусть <span
class="math inline">\(\alpha(1)\alpha(3)\ldots\)</span> – бесконечное
слово. Если существуют <span class="math inline">\(\tau, \tau’ \in
\mathbb{N}\)</span>, такие, что <span class="math inline">\(\alpha(i +
\tau) = \alpha(i) \,\,\,\, \forall i &gt; \tau’ + 1\)</span>, то <span
class="math inline">\(\tau\)</span> – <em>период</em> <span
class="math inline">\(\alpha\)</span>, <span
class="math inline">\(\tau’\)</span> – <em>предпериод</em>.</p>
</div>
<div id="theorem-10">
<p><strong>Теорема:</strong> Конечный инициальный автомат, имеющий <span
class="math inline">\(n\)</span> состояний, преобразует
последовательность (бесконечное слово) <span
class="math inline">\(\alpha\)</span> с наименьшим периодом <span
class="math inline">\(\tau\)</span> в последовательность <span
class="math inline">\(\beta\)</span> с наименьшим периодом вида <span
class="math inline">\(\theta \cdot m\)</span>, где <span
class="math inline">\(\theta \,\,|\,\, \tau\)</span> и <span
class="math inline">\(m \in \{1, \ldots, n\}\)</span>. Если <span
class="math inline">\(|A| \ge 3\)</span> и <span
class="math inline">\(|B| \ge 2\)</span>, то каждое такое значение
периода достигается при нектором автомате <span
class="math inline">\(V_q\)</span> и некторой последовательности <span
class="math inline">\(\alpha\)</span>.</p>
<p><em>Доказательство:</em></p>
<p>Пусть <span class="math inline">\(\alpha_1 = \alpha(1)\ldots
\alpha(\tau’)\)</span> и <span class="math inline">\(\alpha_2 =
\alpha(\tau’ + 1)\ldots \alpha(\tau’ + \tau)\)</span>. Тогда <span
class="math inline">\(\alpha = \alpha_1 \alpha_2 \alpha_2
\ldots\)</span></p>
<p>У автомата <span class="math inline">\(n\)</span> состояний,
следовательно в последовательности <span
class="math inline">\(\varphi(q_1, \alpha_1 \alpha_2), \ldots,
\varphi(q_1, \alpha_1 \alpha_2^{n + 1})\)</span> существуют одинаковые
состояния. Пусть <span class="math inline">\(\varphi(q_1, \alpha_1
\alpha_2^{i_1}) = \varphi(q_1, \alpha_1 \alpha_2^{i_2}) = q, \,\,\,\,
i_1 &lt; i_2\)</span>. Далее возьмем <span
class="math inline">\(\alpha_3 = \alpha_2^{i_2 - i_1}\)</span>. <span
class="math inline">\(q = \varphi(q_1, \alpha_1 \alpha_2^{i_1}) =
\varphi(q_1, \alpha_1 \alpha_2^{i_1} \alpha_3) = \varphi(\varphi(q_1,
\alpha_1 \alpha_2^{i_1}), \alpha_3) = \varphi(q, \alpha_3)\)</span>.</p>
<p><span class="math inline">\(\alpha = \alpha_1 \alpha_2^{i_1} \alpha_3
\alpha_3 \ldots\)</span></p>
<p><span class="math display">\[\beta = \overline{\psi}(q_1, \alpha) =
\overline{\psi}(q_1, \alpha_1 \alpha_3 \alpha_3 \ldots) =
\overline{\psi}(q_1, \alpha_1\alpha_2^{i_1})\overline{\psi}(\varphi(q_1,
\alpha_1\alpha_2^{i_1}), \alpha_3 \alpha_3 \ldots)=\]</span> <span
class="math display">\[= \overline{\psi}(q_1,
\alpha_1\alpha_2^{i_1})\overline{\psi}(q, \alpha_3 \alpha_3 \ldots) =
\overline{\psi}(q_1, \alpha_1\alpha_2^{i_1})\overline{\psi}(q,
\alpha_3)\overline{\psi}(\varphi(q, \alpha_3), \alpha_3 \alpha_3
\ldots)=\]</span></p>
<p>Получаем, что <span class="math inline">\(\overline{\psi}(q_1,
\alpha)\)</span> периодическая последовательность с длиной периода <span
class="math inline">\(|\alpha_3| = (i_2 - i_1)\cdot \tau\)</span>, то
есть минимальный период <span class="math inline">\(\beta\)</span> равен
<span class="math inline">\(\theta \cdot m\)</span>, где <span
class="math inline">\(\theta \,\,|\,\, \tau\)</span> и <span
class="math inline">\(m \in \{1, \ldots, n\}\)</span>.</p>
</div>
<h2 data-number="4.5" id="одинаковость-автоматов">«Одинаковость»
автоматов</h2>
<div id="definition-66">
<p><strong>Определение:</strong> Пусть <span class="math inline">\(V =
(A, Q, B, \varphi, \psi)\)</span> и <span class="math inline">\(V’ = (A,
Q’, B, \varphi’, \psi’)\)</span> – конечные автоматы, <span
class="math inline">\(q \in Q\)</span>, <span class="math inline">\(q’
\in Q’\)</span>. Если <span class="math inline">\(\forall \alpha \in
A^{*} \,\,\,\, \overline{\psi}(q, \alpha) = \overline{\psi’}(q’,
\alpha)\)</span>, то состояния <span class="math inline">\(q\)</span> и
<span class="math inline">\(q’\)</span> <em>неотличимы</em> друг от
друга.<br><br>Если <span class="math inline">\(\exists \alpha \in A^{*}:
\,\,\,\, \overline{\psi}(q, \alpha) \ne \overline{\psi’}(q’,
\alpha)\)</span>, то состояния <span class="math inline">\(q\)</span> и
<span class="math inline">\(q’\)</span> <em>отличимы</em> друг от друга
<em>словом</em> <span class="math inline">\(\alpha\)</span>.</p>
</div>
<div id="definition-67">
<p><strong>Определение:</strong> Если любые два состояния автомата
отличимы, то автомат <em>приведенного типа</em>.</p>
</div>
<div id="definition-68">
<p><strong>Определение:</strong> Пусть <span class="math inline">\(V =
(A, Q, B, \varphi, \psi)\)</span> и <span class="math inline">\(V’ = (A,
Q’, B, \varphi’, \psi’)\)</span> – конечные автоматы. Если <span
class="math inline">\(\forall q \in Q \,\,\,\, \exists q’ \in
Q’\)</span>, такое, что <span class="math inline">\(q\)</span>
неотличимо от <span class="math inline">\(q’\)</span> и <span
class="math inline">\(\forall q’ \in Q’ \,\,\,\, \exists q \in
Q\)</span>, такое, что <span class="math inline">\(q\)</span> неотличимо
от <span class="math inline">\(q’\)</span>, то автоматы <span
class="math inline">\(V\)</span> и <span
class="math inline">\(V’\)</span> <em>неотличимы</em>.</p>
</div>
<div id="definition-69">
<p><strong>Определение:</strong> Пусть <span class="math inline">\(V =
(A, Q, B, \varphi, \psi)\)</span> и <span class="math inline">\(V’ = (A,
Q’, B, \varphi’, \psi’)\)</span> – конечные автоматы. Если существует
биективное отображение <span class="math inline">\(\xi: Q \to
Q’\)</span>, такое, что <span class="math inline">\(\forall a \in A, q
\in Q\)</span> <span class="math display">\[\xi(\varphi(q, a)) =
\varphi’(\xi(q), a)\]</span> <span class="math display">\[\psi(q, a) =
\psi’(\xi(q), a),\]</span> то автоматы <span
class="math inline">\(V\)</span> и <span
class="math inline">\(V’\)</span> <em>изоморфны</em>.</p>
</div>
<div id="theorem-11">
<p><strong>Теорема:</strong> У любого конечного автомата <span
class="math inline">\(V\)</span> существует единственный с точностью до
изоморфизма автомат приведенного типа неотличимый от <span
class="math inline">\(V\)</span>.</p>
<p><em>Доказательство:</em></p>
<p>Разбиваем <span class="math inline">\(Q\)</span> на <span
class="math inline">\(Q_1, \ldots, Q_n\)</span> попарно неотличимых
состояний. Доказываем, что для <span class="math inline">\(q, q’ \in Q_j
\,\,\,\, \varphi(q, a) = \varphi(q’, a) \Rightarrow Q_j = \varphi(Q_i,
a)\)</span>, следовательно получили отображение <span
class="math inline">\(\varphi’: \{Q_1, \ldots, Q_n\}\times A \to \{Q_1,
\ldots, Q_n\}\)</span>.</p>
<p><span class="math inline">\(b = \psi(Q_i, a)\)</span>, следовательно
получили отображение <span class="math inline">\(\psi’: \{Q_1, \ldots,
Q_n\}\times A \to B\)</span>.</p>
<p>Далее проверяем, что автомат <span class="math inline">\((A, \{Q_1,
\ldots, Q_n\}, B, \varphi ’, \psi’)\)</span> неотличим от <span
class="math inline">\(V\)</span> и приведенный.</p>
<p>Единственность с точностью до изоморфизма. Доказываем, что количество
состояний <span class="math inline">\(V\)</span> и <span
class="math inline">\(V’\)</span> одинаковы, и говорим, что <span
class="math inline">\(\xi: q_i \mapsto q_i’\)</span> <span
class="math inline">\(\,\,\,\,\blacksquare\)</span></p>
</div>
<div id="theorem-12">
<p><strong>Теорема:</strong> (Мур #1) Если два состояния автомата <span
class="math inline">\(V = (A, Q, B, \varphi, \psi)\)</span> отличимы, то
существует отличающее их слово длины <span class="math inline">\(|Q| -
1\)</span> и эта оценка неулучшаема.</p>
<p><em>Доказательство:</em> Рассмотрим отношение эквивалентности <span
class="math inline">\(\rho_k\)</span> на <span
class="math inline">\(Q\)</span>. <span class="math inline">\(q_1 \rho_k
q_2 \Leftrightarrow \forall \alpha \in A^{*}: \,\,\,\, |\alpha| = k
\,\,\,\, \varphi(q_1, \alpha) = \varphi(q_2, \alpha)\)</span>.</p>
<p><span class="math inline">\(Q\)</span> разбивается на классы
эквивалентности <span class="math inline">\(R_1, \ldots,
R_n\)</span>.</p>
<p>Докажем, что в <span class="math inline">\(R_1\)</span> не менее двух
состояний. Пусть <span class="math inline">\(q\)</span> и <span
class="math inline">\(q’\)</span> неотличимые состояния автомата <span
class="math inline">\(V\)</span>, то есть существует непустое слово
(возьмем такое слово минимальной длины) <span
class="math inline">\(\alpha’ a, \,\,\,\, \alpha ’ \in A^{*}, \,\,\,\,a
\in A\)</span>, которое отличает <span class="math inline">\(q\)</span>
и <span class="math inline">\(q’\)</span>. Так как длина наименьшая
слово <span class="math inline">\(\alpha’ a\)</span> отличает <span
class="math inline">\(q\)</span> и <span
class="math inline">\(q’\)</span> последней буквой, то есть <span
class="math inline">\(\varphi(\varphi(q, \alpha’), a) = \varphi(q,
\alpha’ a) \ne \varphi(q’, \alpha’ a) = \varphi(\varphi(q’, \alpha’),
a)\)</span>. По индукции доказывается, что <span
class="math inline">\(|R_i| \le i + 1\)</span>.</p>
<p>Очевидно, что <span class="math inline">\(R_k \subset R_{k + 1}
\,\,\,\, \forall k\)</span>, но, так как состояний конечное количество,
в какой-то момент <span class="math inline">\(R_k = R_{k + 1} = \ldots =
R\)</span></p>
<p>Получаем, что <span class="math inline">\(|Q| \ge |R_k| \ge k + 1
\Rightarrow k \le |Q| - 1 \,\,\,\,\blacksquare\)</span></p>
</div>
<p><strong>Пример</strong>, показывающий неулучшаемость оценки…</p>
<h2 data-number="4.6"
id="распознавание-событий-конечными-автоматами">Распознавание событий
конечными автоматами</h2>
<div id="definition-70">
<p><strong>Определение:</strong> Пусть <span class="math inline">\(V =
(A, Q, B , \varphi, \psi, q)\)</span> – инициальный конечный автомат.
Любое подмножество <span class="math inline">\(A^{*} \setminus
\Lambda\)</span> – <em>событие</em>.</p>
</div>
<div id="definition-71">
<p><strong>Определение:</strong> Пусть <span class="math inline">\(V =
(A, Q, B , \varphi, \psi, q)\)</span> – инициальный конечный автомат,
<span class="math inline">\(B’ \subset B\)</span>. Множество <span
class="math inline">\(M = \{\alpha \in A^{*} \setminus \Lambda:
\,\,\,\,\psi(q, \alpha) \in B’\}\)</span> – событие,
<em>представимое</em> автоматом <span class="math inline">\(V\)</span>
посредством <span class="math inline">\(B’\)</span>.</p>
</div>
<div id="definition-72">
<p><strong>Определение:</strong> Пусть <span
class="math inline">\(M_1\)</span> и <span
class="math inline">\(M_2\)</span> события. Множество <span
class="math inline">\(M_1\cdot M_2 = \{\alpha_1 \alpha_2: \,\,\,\,
\alpha_1 \in M_1, \alpha_2 \in M_2\}\)</span> – <em>произведение
событий</em> <span class="math inline">\(M_1\)</span> и <span
class="math inline">\(M_2\)</span>.</p>
</div>
<div id="definition-73">
<p><strong>Определение:</strong> Пусть <span
class="math inline">\(M\)</span> – событие. Множество <span
class="math inline">\(&lt;M&gt; = \{\alpha_1\ldots \alpha_k: \,\,\,\,
\alpha_i \in M\}\)</span> – <em>итерация события</em> <span
class="math inline">\(M\)</span>.</p>
</div>
<h3 data-number="4.6.1"
id="простейшие-свойства-итерации-и-произведения-событий">Простейшие
свойства итерации и произведения событий</h3>
<div id="statement-28">
<p><strong>Утверждение:</strong> Пусть <span
class="math inline">\(M\)</span> – событие. Тогда</p>
<ol type="1">
<li><span class="math inline">\(M \cdot \varnothing = \varnothing \cdot
M\)</span></li>
<li><span class="math inline">\(&lt;\varnothing&gt; =
\varnothing\)</span></li>
<li><span class="math inline">\(&lt;M&gt; = M \cdot &lt;M&gt; \cup
M\)</span></li>
<li><span class="math inline">\(&lt;M&gt;\cdot M = M \cdot
&lt;M&gt;\)</span></li>
</ol>
<p><em>Доказательство:</em> <span
class="math inline">\(\,\,\,\,\blacksquare\)</span></p>
</div>
<div id="statement-29">
<p><strong>Утверждение:</strong> Пусть <span class="math inline">\(X, C,
D\)</span> – события. Тогда <span class="math inline">\(X = XC \cup D
\,\,\,\, \Leftrightarrow \,\,\,\, X = D &lt;C&gt; \cup D\)</span>.</p>
<p><em>Доказательство:</em> <span
class="math inline">\(\not\subset\)</span></p>
</div>
<h3 data-number="4.6.2" id="регулярные-события">Регулярные события</h3>
<div id="definition-74">
<p><strong>Определение:</strong> <br><br>1. События <span
class="math inline">\(\varnothing\)</span> и <span
class="math inline">\(a \in A\)</span> – <em>регулярные</em>.<br>2. Если
<span class="math inline">\(R_1\)</span> и <span
class="math inline">\(R_2\)</span> регулярные события, то <span
class="math inline">\(R_1 \cdot R_2\)</span>, <span
class="math inline">\(R_1 \cup R_2\)</span> и <span
class="math inline">\(&lt;R_1&gt;\)</span> – <em>регулярные</em>
события.</p>
</div>
<div id="statement-30">
<p><strong>Утверждение:</strong> Пусть <span
class="math inline">\(R_{ij}, \,\,\,\, i \in \{0, \ldots, n\}, \,\,\,\,
j \in \{1, \ldots, n\}\)</span> и <span class="math inline">\(X_1,
\ldots, X_n\)</span> удовлетворяют системе уравнений: <span
class="math display">\[X_1 = X_1 \cdot R_{11} \cup \ldots \cup X_n \cdot
R_{n1} \cup R_{01}\]</span> <span class="math display">\[X_2 = X_1 \cdot
R_{12} \cup \ldots \cup X_n \cdot R_{n2} \cup R_{02}\]</span> <span
class="math display">\[\vdots\]</span> <span class="math display">\[X_n
= X_1 \cdot R_{1n} \cup \ldots \cup X_n \cdot R_{nn} \cup
R_{0n}\]</span> Тогда <span class="math inline">\(X_1, \ldots,
X_n\)</span> – регулярные события.</p>
<p><em>Доказательство:</em> Индукция по <span
class="math inline">\(n\)</span>.</p>
<p><strong>База:</strong> <span class="math inline">\(n = 1 \Rightarrow
X_1 = X_1 \cdot R_{11}\cup R_{01}\)</span> следует из утверждения <span
class="math inline">\(\,\,\,\,\blacksquare\)</span></p>
<p><strong>Шаг:</strong> ну, пооочти очев <span
class="math inline">\(\,\,\,\,\blacksquare\)</span></p>
</div>
<div id="statement-31">
<p><strong>Утверждение:</strong> События представимые в инициальном
конечном автомате – регулярные.</p>
<p><em>Доказательство:</em></p>
<p>Пусть <span class="math inline">\(V = (A, Q, B, \varphi, \psi,
q_1)\)</span>, <span class="math inline">\(Q = \{q_1, \ldots,
q_n\}\)</span>, <span class="math inline">\(M\)</span> – событие,
представимое посредством <span class="math inline">\(B’\)</span>.</p>
<p><span class="math display">\[M_i = \{\alpha \in A^{*}\setminus
\Lambda: \,\,\,\, \varphi(q_1, \alpha) = q_i\}\]</span></p>
<p><span class="math display">\[M_i’ = \{a \in A^{*} (|a| = 1): \,\,\,\,
\psi(q_i, a) \in B’\}\]</span></p>
<p><span class="math display">\[\Downarrow\]</span></p>
<p><span class="math display">\[M = M_1 M_1’ \cup \ldots \cup M_n
M_n’\]</span></p>
<p><span class="math inline">\(M_i’\)</span> – регулярно.</p>
<p><span class="math display">\[R_{ij} = \{a \in A^{*} (|a| = 1):
\,\,\,\, \varphi(q_i, a) = q_j\}, \,\,\,\, i, j \in \{1, \ldots,
n\}\]</span></p>
<p><span class="math inline">\(R_{ij}\)</span> – регулярно.</p>
<p><span class="math display">\[M_1 = M_1 R_{11} \cup \ldots \cup M_n
R_{n1} \cup R_{11}\]</span> <span class="math display">\[\vdots\]</span>
<span class="math display">\[M_n = M_n R_{1n} \cup \ldots \cup M_n
R_{nn} \cup R_{1n}\]</span></p>
<p><span class="math display">\[\Downarrow\]</span></p>
<p><span class="math inline">\(M_i\)</span> – регулярно <span
class="math inline">\(\,\,\,\,\blacksquare\)</span></p>
</div>
<h2 data-number="4.7" id="обобщенные-источники">Обобщенные
источники</h2>
<div id="definition-75">
<p><strong>Определение:</strong> Пусть <span
class="math inline">\(A\)</span> – алфавит. <em>Обобщенный источник (в
алфавите)</em> <span class="math inline">\(A\)</span> – это конечный
ориентированный граф, каждому ребру которого сопоставлен символ <span
class="math inline">\(a \in A\)</span> или пустое слово <span
class="math inline">\(\Lambda\)</span>, и в котором выбраны начальная
вершина <span class="math inline">\(v\)</span> и финальная вершина <span
class="math inline">\(w\)</span>.</p>
</div>
<div id="definition-76">
<p><strong>Определение:</strong> Пусть <span
class="math inline">\(G\)</span> – обобщенный источник. <span
class="math inline">\(v_1\)</span> и <span class="math inline">\(v_{n +
1}\)</span> вершины <span class="math inline">\(G\)</span>.
Последовательность <span class="math inline">\(\pi_{v_1 \to v_{n + 1}}:
\,\,\,\, v_1, e_1, \ldots, v_n, e_n, v_{n + 1}\)</span> – <em>путь</em>
от вершины <span class="math inline">\(v_1\)</span> к вершине <span
class="math inline">\(v_{n + 1}\)</span>.<br><span
class="math inline">\([\pi]\)</span> – это слово составленное из
символов ребер, входящих в путь <span
class="math inline">\(\pi\)</span>.</p>
</div>
<div id="definition-77">
<p><strong>Определение:</strong> Пусть <span
class="math inline">\(A\)</span> – алфавит, <span
class="math inline">\(G\)</span> – обобщенный источник, <span
class="math inline">\(\alpha \in A^{*}\)</span>, <span
class="math inline">\(u\)</span> – вершина <span
class="math inline">\(G\)</span>. <span class="math inline">\(\theta(u,
\alpha) = \{v \in G: \,\,\,\, \exists \pi_{u \to v}: \,\,\,\, [\pi] =
\alpha\}\)</span>.</p>
</div>
<div id="definition-78">
<p><strong>Определение:</strong> Пусть <span
class="math inline">\(A\)</span> – алфавит, <span
class="math inline">\(G\)</span> – обобщенный источник с начальной
вершиной <span class="math inline">\(v\)</span> и финальной вершиной
<span class="math inline">\(w\)</span>. <em>Событие</em> <span
class="math inline">\(|G|\)</span>, <em>определяемое источником</em>
<span class="math inline">\(G\)</span> – это <span
class="math inline">\(|G| = \{\alpha \in A^{*}: \,\,\,\, w \in \theta(v,
\alpha)\}\)</span>.</p>
</div>
<div id="statement-32">
<p><strong>Утверждение:</strong> Если <span
class="math inline">\(R\)</span> – регулярное событие, то существует
обобщенный источник <span class="math inline">\(G\)</span>, такой, что
<span class="math inline">\(|G| = R\)</span>.</p>
<p><em>Доказательство:</em> индукция по определению регулярного события
с помощью картинок <span
class="math inline">\(\,\,\,\,\blacksquare\)</span></p>
</div>
<div id="statement-33">
<p><strong>Утверждение:</strong> Пусть <span
class="math inline">\(G\)</span> – обобщенный источник. Тогда <span
class="math inline">\(|G|\)</span> представимо.</p>
<p><em>Доказательство:</em></p>
<p>Пусть <span class="math inline">\(M = \{v_1, \ldots, v_n\}\)</span> –
множество вершин <span class="math inline">\(G\)</span>, <span
class="math inline">\(v_1\)</span> – начальная вершина, <span
class="math inline">\(v_n\)</span> – финальная вершина. Пусть <span
class="math inline">\(Q = 2^M\)</span> и <span
class="math inline">\(\varphi: Q\times A \to Q\)</span> определена
так:</p>
<p><span class="math display">\[\varphi(q, a) = \displaystyle\cup_{v \in
q}\theta(v, a)\]</span> <span class="math display">\[\psi(q, a) =
\begin{cases}
1, v_n \in \varphi(q, a)\\
0,
\end{cases}\]</span></p>
<p><span class="math display">\[\forall \alpha \in A^{*}\setminus
\Lambda \,\,\,\, \psi(q, \alpha) = 1 \Leftrightarrow v_n \in \varphi(q,
\alpha)\]</span></p>
<p>Докажем по индукции по длине слова, что <span
class="math inline">\(\forall \alpha \in A^{*}\setminus \Lambda\)</span>
выполнено:</p>
<p><span class="math display">\[\varphi(\{v_1\}, \alpha) = \theta(v_1,
\alpha)\]</span></p>
<p><strong>База:</strong> <span class="math inline">\(|\alpha| =
1\)</span> выполнено по определению <span
class="math inline">\(\varphi\)</span>.</p>
<p><strong>Шаг:</strong></p>
<p><span class="math display">\[\varphi(\{v_1\}, \alpha) =
\varphi(\varphi(\{v_1\}, \alpha’), a) = \varphi(\theta(v_1, \alpha’), a)
= \displaystyle\bigcup_{v \in \theta(v_1, \alpha’)}\theta(v,
a)\]</span></p>
<p><span class="math display">\[\theta(\{v_1\}, \alpha) =
\displaystyle\bigcup_{v \in \theta(v_1, \alpha’)}\theta(v, a)
\,\,\,\,\blacksquare\]</span></p>
</div>
<div id="theorem-13">
<p><strong>Теорема:</strong> (Клини) Событие представимо тогда и только
тогда, когда оно регулярно.</p>
<p><em>Доказательство:</em> см. <span class="math inline">\(1\)</span> и
<span class="math inline">\(2\)</span> <span
class="math inline">\(\,\,\,\,\blacksquare\)</span></p>
</div>
<div id="statement-34">
<p><strong>Утверждение:</strong> Существуют непредставимые события.</p>
<p><em>Доказательство:</em> Множество всех событий континуально,
множество представимых событий счетно <span
class="math inline">\(\,\,\,\,\blacksquare\)</span></p>
</div>
<div id="statement-35">
<p><strong>Утверждение:</strong> Событие <span
class="math inline">\(M\)</span> в алфавите <span
class="math inline">\(\{0, 1\}\)</span>, состоящее из
последовательностей с одинаковым количеством нулей и единиц
непредставимо.</p>
<p><em>Доказательство:</em> <span
class="math inline">\(\,\,\,\,\blacksquare\)</span></p>
</div>
<h2 data-number="4.8" id="структурные-автоматы">Структурные
автоматы</h2>
<div id="definition-79">
<p><strong>Определение:</strong> Пусть <span class="math inline">\(V_q =
(\{0, 1\}^n, Q, \{0, 1\}^m, \varphi, \psi, q)\)</span> – инициальный
конечный автомат. Множество всех автоматных функций <span
class="math inline">\(f(\alpha) = \overline{\psi}(q, \alpha)\)</span>,
задаваемых автоматами вида <span class="math inline">\(V_q\)</span>
обозначается <span
class="math inline">\(P_{\operatorname{авт}}\)</span>.</p>
</div>
<div id="definition-80">
<p><strong>Определение:</strong> Пусть <span class="math inline">\(f \in
P_{\operatorname{авт}}\)</span>, <span class="math inline">\(\alpha \in
(\{0, 1\}^n)^{*}\)</span>(слово, буквы которого – это последовательности
нулей и единиц), <span class="math inline">\(\alpha = \alpha(1)\ldots
\alpha(l)\)</span>, <span class="math inline">\(\alpha(i) =
(\alpha_1(i), \ldots, \alpha_n(i))\)</span> (функция <span
class="math inline">\(\alpha_j\)</span> – это <span
class="math inline">\(j\)</span>-й элемент буквы). Пусть <span
class="math inline">\(\alpha_j = (\alpha_j(1), \ldots,
\alpha_j(l))\)</span> (взяли <span class="math inline">\(j\)</span>-й
элемент каждой буквы слова <span class="math inline">\(\alpha\)</span>).
Определим функцию <span class="math inline">\(g(\alpha_1, \ldots,
\alpha_n) = f(\alpha)\)</span>.<br><br> Если <span
class="math inline">\(i\)</span>-я переменная функции <span
class="math inline">\(g\)</span> существенная, то <span
class="math inline">\(i\)</span>-й вход автомата
<em>существенный</em>.<br><br>Если функция <span
class="math inline">\(\psi_j\)</span>(см. канонические уравнения)
зависит от <span class="math inline">\(a_i(t)\)</span> фиктивно, то
<span class="math inline">\(j\)</span>-й выход автомата <em>зависит</em>
от <span class="math inline">\(i\)</span>-ого <em>с задержкой</em>.</p>
</div>
<div id="definition-81">
<strong>Определение:</strong>
<details>
<summary>
</summary>
Тут будет лажа
</details>
<p>Пусть <span class="math inline">\(E\)</span> – это множество
схем-компонент (квадратиков с пометкой). Пусть <span
class="math inline">\(\Sigma: E \to \{f_1, \ldots, f_p\} \subset
P_{\operatorname{авт}}\)</span> (<em>сигнатура</em>).</p>
<p>Схему <span class="math inline">\(E_i\)</span>, которой соответствует
<span class="math inline">\(f_i = \Sigma(E_i)\)</span>, будем обозначать
квадратом, в который входит <span class="math inline">\(n \ge 0\)</span>
стрелок (количество входов автомата, задаваемого <span
class="math inline">\(f_i\)</span>) и выходит <span
class="math inline">\(m \ge 1\)</span> стрелок (количество выходов
автомата, задаваемого <span class="math inline">\(f_i\)</span>).</p>
</div>
<div id="definition-82">
<p><strong>Определение:</strong></p>
<ol type="1">
<li><p>Элемент <span class="math inline">\(E_i \subset E\)</span> –
<em>схема</em>.</p></li>
<li><p>Схема – это штука, полученная при помощи операций:</p></li>
</ol>
<ol type="a">
<li>Переподключения входов и выходов схемы (при переподключении входов
важно, чтобы все существенные входы сохранились)</li>
<li>Объединения непересекающихся схем.</li>
<li>Операции обратной связи (вклеивание стрелки ведущей от выхода,
зависящего от некоторого входа с задержкой, в этот вход)</li>
</ol>
</div>
<div id="definition-83">
<p><strong>Определение:</strong> Операции <span class="math inline">\(a,
b, c\)</span> – это операции <em>композиции</em>.</p>
</div>
<div id="definition-84">
<p><strong>Определение:</strong> Множество всех функций, полученных
операциями композиции из <span class="math inline">\(F \subset
P_{\operatorname{авт}}\)</span>, обозначается <span
class="math inline">\([F]\)</span>.</p>
</div>
<div id="definition-85">
<p><strong>Определение:</strong> <span class="math inline">\(F \subset
P_{\operatorname{авт}}\)</span> <em>полная</em>, если <span
class="math inline">\([F] = P_{\operatorname{авт}}\)</span></p>
</div>
<h3 data-number="4.8.1"
id="пример-полной-относительно-композиций-системы">Пример полной
относительно композиций системы</h3>
<div id="definition-86">
<p><strong>Определение:</strong> Если функция <span
class="math inline">\(f \in P_{\operatorname{авт}}\)</span> pеализуется
схемой в сигнатуре, построенной только при помощи операций
переобозначения входов и выходов, объединения схем и их
последовательного соединения, то <span class="math inline">\(f\)</span>
получена <em>суперпозициями</em> из функций <span
class="math inline">\(\{f_1,\ldots, f_p\}\)</span> данной сигнатуры.
Множество всех функций, полученных операциями суперпозиции из функций
множества <span class="math inline">\(F \subset
P_{\operatorname{авт}}\)</span>, обозначается <span
class="math inline">\([F]_c\)</span>. Система <span
class="math inline">\(F \subset P_{\operatorname{авт}}\)</span>
<em>полна</em> относительно суперпозиций, если <span
class="math inline">\([F]_c = P_{\operatorname{авт}}\)</span>.</p>
</div>
<div id="theorem-14">
<p><strong>Теорема:</strong> В <span
class="math inline">\(P_{\operatorname{авт}}\)</span> не существует
конечной полной относительно суперпозиций системы функций.</p>
<p><em>Доказательство:</em></p>
</div>
<h2 data-number="4.9" id="однородные-структуры">Однородные
структуры</h2>
<div id="definition-87">
<p><strong>Определение:</strong> <em>Однородная структура</em> – это
<span class="math inline">\(\sigma = (\mathbb{Z}^k, E_n, V,
\varphi)\)</span>, где <br><br> <span
class="math inline">\(\mathbb{Z}^k\)</span> – множество <span
class="math inline">\(k\)</span>-мерных целочисленных векторов
(координаты клеток дискретного пространства (все нормальные люди
используют <span class="math inline">\(\mathbb{Z}^2\)</span>, но
математик должен быть ненормальным, особенно, в 01:00))<br><br> <span
class="math inline">\(E_n = \{0, \ldots, n - 1\}\)</span> – множество
кодов состояний (каждая клетка в каждый момент времени находится в
каком-то состоянии) <br><br> <span class="math inline">\(V = \{\alpha_1,
\ldots, \alpha_{h - 1}: \,\,\,\, \alpha_i \in \mathbb{Z}^k, \,\,\,\,
\alpha_i \ne \alpha_j, \,\,\,\, i \ne j\}\)</span> – <em>шаблон
соседства клетки</em> (кого видит клетка)<br><br> <span
class="math inline">\(\varphi: (E_n)^h \to E_n\)</span> – <em>функция
изменения состояния клетки</em>(<em>локальная функция переходов</em>)
(зависит от <span class="math inline">\(h\)</span> переменных –
состояний соседей клетки) и <span class="math inline">\(\varphi(0,
\ldots, 0) = 0\)</span>.</p>
</div>
<div id="definition-88">
<p><strong>Определение:</strong> Пусть <span
class="math inline">\(\sigma\)</span> – однородная структура.
<em>Состояние однородной структуры</em> <span
class="math inline">\(\sigma\)</span> – это функция <span
class="math inline">\(f: \mathbb{Z}^k \to E_n\)</span>.</p>
</div>
<div id="definition-89">
<p><strong>Определение:</strong> Пусть <span
class="math inline">\(\sigma\)</span> – однородная структура и задано
некоторое множество ее состояний <span class="math inline">\(F\)</span>.
<em>Основная (глобальная) функция переходов однородной структуры</em> –
это <span class="math inline">\(\Phi: F \to F\)</span>, такая, что <span
class="math display">\[\Phi(f)(\alpha) = \varphi(f(\alpha), f(\alpha +
\alpha_1), \ldots, f(\alpha + \alpha_{h - 1})), \,\,\,\, f \in F,
\,\,\,\, \alpha \in \mathbb{Z}^k\]</span></p>
</div>
<div id="definition-90">
<p><strong>Определение:</strong> <em>Поведение однородной структуры</em>
– это последовательность ее состояний <span class="math inline">\(f_0,
f_1, f_2, \ldots\)</span>, такая, что <span class="math inline">\(f_{i +
1} = \Phi(f_i)\,\,\,\, \forall i\)</span>.</p>
</div>
<div id="definition-91">
<p><strong>Определение:</strong> <em>Конфигурация однородной
структуры</em> – это такое ее состояние, при котором только конечное
число клеток имеют ненулевое значение.</p>
</div>
<div id="statement-36">
<p><strong>Утверждение:</strong> При переходе к новому состоянию
конфигурация однородной структуры остается конфигурацией.</p>
<p><em>Доказательство:</em> <span
class="math inline">\(\,\,\,\,\blacksquare\)</span></p>
</div>
<center>
<canvas id="life-canvas">
</canvas>
</center>
<div id="definition-92">
<p><strong>Определение:</strong> Однородная структура <span
class="math inline">\(\sigma = (\mathbb{Z}^2, E_k, V, \varphi)\)</span>,
у которой <span class="math inline">\(V(\alpha)\)</span> квадрат со
стороной <span class="math inline">\(2\cdot m + 1\)</span> с центром в
<span class="math inline">\(\alpha, \,\,\,\, \alpha \in
\mathbb{Z}^2\)</span> – <em>квадратная</em>.</p>
</div>
<div id="definition-93">
<p><strong>Определение:</strong> Пусть <span class="math inline">\(K
\subset \mathbb{Z}^2\)</span> – квадрат. <span
class="math inline">\(V(K) = \displaystyle\bigcup_{\alpha \in
K}V(\alpha)\)</span> – <em>окрестность квадрата</em>.</p>
</div>
<div id="statement-37">
<p><strong>Утверждение:</strong> Окрестность квадрата – квадрат.</p>
<p><em>Доказательство:</em> <span
class="math inline">\(\,\,\,\,\blacksquare\)</span></p>
</div>
<div id="definition-94">
<p><strong>Определение:</strong> <em>Состояние окрестности квадрата</em>
– это функция <span class="math inline">\(f: V(K) \to E_k\)</span>.
Функция <span class="math inline">\(g = \Phi_K(f)\)</span> – это
ограничение глобальной функции переходов, определенной на состояниях
окрестности квадрата на сам квадрат.<br><br>Состояние квадрата –
<em>конфигурация</em>.<br><br>Если конфигурация квадрата не принадлежит
множеству значений <span class="math inline">\(\Phi_K\)</span>, то она
<em>неконструируемая</em>.</p>
</div>
<div id="definition-95">
<p><strong>Определение:</strong> Пусть <span
class="math inline">\(f_1\)</span> и <span
class="math inline">\(f_2\)</span> – конфигурации квадрата <span
class="math inline">\(V(V(K))\)</span>. Если <br><br>1. <span
class="math inline">\({f_1}_{|K} \ne {f_2}_{|K}\)</span><br>2. <span
class="math inline">\({f_1}_{|V(V(K))\setminus K} =
{f_2}_{|V(V(K))\setminus K}\)</span><br>3. <span
class="math inline">\(\Phi_{V(K)}(f_1)_{|K} =
\Phi_{V(K)}(f_2)_{|K}\)</span>, то конфигурации <span
class="math inline">\(f_1\)</span> и <span
class="math inline">\(f_2\)</span> – <em>взаимностираемые</em>.</p>
</div>
<div id="theorem-15">
<p><strong>Теорема:</strong> (Мур #100500) Пусть <span
class="math inline">\(\sigma = (\mathbb{Z}^2, E_k, V, \varphi)\)</span>
– квадратная однородная структура, где <span
class="math inline">\(V(\alpha)\)</span> – квадрат со стороной <span
class="math inline">\(2\cdot m + 1\)</span>. Тогда существование в <span
class="math inline">\(\sigma\)</span> взаимностираемых конфигураций
<span class="math inline">\(\Leftrightarrow\)</span> существуют
неконструируемые конфигурации.</p>
<p><em>Доказательство:</em></p>
<p>Пусть <span class="math inline">\(f_1\)</span> и <span
class="math inline">\(f_2\)</span> взаимностираемые конфигурации на
квадрате <span class="math inline">\(K\)</span>.</p>
<p>Пусть <span class="math inline">\(K’ = V(V(K))\)</span>. Определим на
<span class="math inline">\(K’\)</span> отношение эквивалентности
состояний. <span class="math inline">\(f_1 \sim f_2 \Leftrightarrow
f_1\)</span> и <span class="math inline">\(f_2\)</span> взаимностираемые
на квадрате <span class="math inline">\(K\)</span> или <span
class="math inline">\(f_1\)</span> и <span
class="math inline">\(f_2\)</span> совпадают.</p>
<p>Пусть длина стороны <span class="math inline">\(K’\)</span> – это
<span class="math inline">\(l\)</span>. Тогда множество состояний <span
class="math inline">\(K’\)</span> равно <span
class="math inline">\(k^{l^2}\)</span>. Но по условию существует хотя бы
один класс эквивалентности, в котором <span class="math inline">\(\ge
2\)</span> элемента, следовательно мощность множества классов
эквивалентности не превосходит <span class="math inline">\(k^{l^2} -
1\)</span>.</p>
<p>Пусть <span class="math inline">\(N \in \mathbb{N}\)</span>.
Рассмотрим квадрат <span class="math inline">\(\tilde{K}\)</span> с
длиной стороны <span class="math inline">\(l N\)</span>, то есть решетку
<span class="math inline">\(N\)</span> на <span
class="math inline">\(N\)</span> из квадратов <span
class="math inline">\(K’\)</span>.</p>
<p><span class="math inline">\(\tilde{K}\)</span> окрестность некторого
квадата <span class="math inline">\(\hat{K}\)</span> с длиной стороны -
<span class="math inline">\(l M - 2 m\)</span>.</p>
<p>Пусть <span class="math inline">\(\tilde{f}_1\)</span> и <span
class="math inline">\(\tilde{f}_2\)</span> состояния квадрата <span
class="math inline">\(\tilde{K}\)</span>, такие, что их сужения на
каждый из подквадратов <span class="math inline">\(K’\)</span>
эквивалентны. Докажем, что <span
class="math inline">\(\Phi_{\hat{K}}(\tilde{f}_1) =
\Phi_{\hat{K}}(\tilde{f}_2)\)</span>. Положим, что очевидно.</p>
<p>Следовательно, число состояний <span
class="math inline">\(\Phi_{\hat{K}}\)</span> не превосходит <span
class="math inline">\(\left(k^{l^2} - 1\right)^{N^2}\)</span>, а общее
число состояний <span class="math inline">\(\hat{K}\)</span> – это <span
class="math inline">\(k^{(l N - 2 m)^2}\)</span>.</p>
<p>Рассмотрим отношение числа состояний, которые могут быть получены, к
числу возможных состояний <span class="math display">\[\eta =
\frac{\left(k^{l^2} - 1\right)^{N^2}}{k^{(l N - 2 m)^2}} =
\left(\frac{k^{l^2} - 1}{k^{\frac{(l N - 2
m)^2}{N^2}}}\right)^{N^2}\]</span></p>
<p>Существует <span class="math inline">\(N\)</span>, такое, что <span
class="math inline">\(\eta &lt; 1 \,\,\,\,\blacksquare\)</span></p>
</div>
<p><img src="img/cg.png" id="inv" /> <img src="img/cp.png" id="inv" />
<img src="img/cy.png" id="inv" /> <img src="img/dhs2.png" id="inv" />
<img src="img/purple_heart.png" id="inv" /> <img src="img/red_heart.png"
id="inv" /></p>
<script>
    var requestAnimFrame = (function(){
    return window.requestAnimationFrame    ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame    ||
        window.oRequestAnimationFrame      ||
        window.msRequestAnimationFrame     ||
        function(callback){
            window.setTimeout(callback, 1000 / 60);
        };
})();

const Resources = {
    loaded: 0,
    total: 0,
    images: {},
    onComplete: null,

    load(urls) {
        this.total = urls.length;
        this.loaded = 0;

        for (let i = 0; i < urls.length; i++) {
            const url = urls[i];
            const image = new Image();

            image.addEventListener('load', () => {
                this.loaded++;
                this.images[url] = image;

                if (this.loaded === this.total && typeof this.onComplete === 'function') {
                    this.onComplete();
                }
            });

            image.addEventListener('error', () => {
                console.error(`Error loading image: ${url}`);

                this.loaded++;

                if (this.loaded === this.total && typeof this.onComplete === 'function') {
                    this.onComplete();
                }
            });

            image.src = url;
        }
    },

    onReady(callback) {
        if (typeof callback === 'function') {
            this.onComplete = callback;

            if (this.loaded === this.total) {
                this.onComplete();
            }
        }
    },

    get(url) {
        return this.images[url] || null;
    }
};

const canvas = document.getElementById("main-canvas");
const ctx = canvas.getContext("2d");

const comp_table_canvas = document.getElementById('table-canvas');
const comp_table_ctx = comp_table_canvas.getContext('2d');

const diam_table_canvas = document.getElementById('diam-table-canvas');
const diam_table_ctx = diam_table_canvas.getContext('2d');

const heart_table_canvas = document.getElementById('heart-table-canvas');
const heart_table_ctx = heart_table_canvas.getContext('2d');

const diagram_canvas = document.getElementById('diagram-canvas');
const diagram_ctx = diagram_canvas.getContext('2d');

const computers_table = [
  ['img/cp.png', 'img/cy.png', 'img/cg.png'],
];

const hearts_table = [["red_heart", "purple_heart"]];
const diamonds_table = [["purple", "cyan", "green", "red"],
                        ["orange", "pink", "yellow", "grey"]]

const margin = 30;
const space = 30;

const width = 500;
const height = 300;
const table_height = 300;
canvas.width = width;
canvas.height = height;

comp_table_canvas.width = width;
diam_table_canvas.width = width;
heart_table_canvas.width = width;

diagram_canvas.width = width;
diagram_canvas.height = width;

const boxWidth = 129;
const boxHeight = 138;
const boxX = width / 2 - boxWidth / 2;
const boxY = height / 2 - boxHeight / 2;

const leftSpriteX = boxX - 50;
const leftSpriteY = boxY + boxHeight / 2;
const rightSpriteX = boxX + boxWidth + 50;
const rightSpriteY = boxY + boxHeight / 2;

const sprites = {
    "purple": [0, 0],
    "cyan": [0, 1],
    "green": [0, 2],
    "red": [0, 3],
    "orange": [0, 4],
    "pink": [1, 0],
    "blue": [1, 1],
    "yellow": [1, 2],
    "grey": [1, 4],
    "red_heart": [2, 1],
    "purple_heart": [2, 2],
};

let a = "red_heart";
const states = ["purple", "cyan", "green", "red", "orange", "pink", "yellow", "grey"];
const computers = ["img/cy.png", "img/cg.png", "img/cp.png"];

let dashOffset = 0;
let index = 0;
const dashSpeed = 1;
let spriteWidth = 80;
let spriteHeight = 80;


function main() {
    drawBox();
    requestAnimFrame(main);
};


function init() {
    drawTable(computers_table, 50, 70, 20, drawComp, comp_table_ctx, comp_table_canvas);
    drawTable(diamonds_table, 50, 50, 20, drawSprite, diam_table_ctx, diam_table_canvas);
    drawTable(hearts_table, 50, 100, 50, drawSprite, heart_table_ctx, heart_table_canvas);
    drawDiagram();
    main();
}

const resources = Object.create(Resources);

resources.load([
    'img/cy.png',
    'img/cg.png',
    'img/cp.png',
    'img/dhs2.png'
]);
resources.onReady(init);

function drawDiagram() {
    const comp1 = resources.get("img/cy.png");
    const comp2 = resources.get("img/cg.png");
    const comp3 = resources.get("img/cp.png");

    const x1 = width / 2 - comp1.width / 2;
    const y1 = 50;

    const x2 = width / 5 - comp2.width / 2;
    const y2 = width - y1 - comp2.height;

    const x3 = 4 * width / 5 - comp2.width / 2;
    const y3 = width - y1 - comp2.height;

    diagram_ctx.drawImage(comp1, x1, y1, boxWidth, boxHeight);
    diagram_ctx.drawImage(comp2, x2, y2, boxWidth, boxHeight);
    diagram_ctx.drawImage(comp3, x3, y3, boxWidth, boxHeight);

}


function drawTable(table, margin_top, margin_side, space, draw_function, ctx, canvas) {
    const n_cols = table[0].length;
    const n_rows = table.length;
    const cellWidth = (width - 2 * margin_side - space * (n_cols - 1)) / n_cols;
    const cellHeight = cellWidth;
    canvas.height = 2 * margin_top + n_rows * cellHeight;
    for (let row = 0; row < n_rows; row++) {
        for (let col = 0; col < n_cols; col++) {

            const x = margin_side + col * (cellWidth + space);
            const y = margin_top + row * cellHeight;

            draw_function(table[row][col], x, y, cellWidth, cellHeight, ctx);
        }
    }
}

function drawComp(img_url, x, y, cellWidth, cellHeight, ctx) {
    ctx.drawImage(resources.get(img_url), x, y, cellWidth, cellHeight);
}

function drawSprite(name, x, y, cellWidth, cellHeight, ctx) {
    const sprite = sprites[name];
    const image = resources.get('img/dhs2.png');

    ctx.drawImage(
        image,
        sprite[1] * spriteWidth,
        sprite[0] * spriteHeight,
        spriteWidth,
        spriteHeight,
        x,
        y,
        cellWidth,
        cellHeight
    );
}

function drawBox() {
    const sprite = sprites[states[index % states.length]];
    const x = sprite[1];
    const y = sprite[0];
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    dashOffset += dashSpeed;
    if (dashOffset > 10)
    {
        dashOffset = 0;
    }

    ctx.beginPath();
    ctx.setLineDash([5, 5]);
    ctx.lineDashOffset = -dashOffset;
    ctx.moveTo(leftSpriteX - spriteWidth / 2, leftSpriteY);
    ctx.lineTo(boxX, boxY + boxHeight / 2);
    ctx.lineTo(rightSpriteX + spriteWidth / 2, rightSpriteY);
    ctx.strokeStyle = "black";
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.drawImage(resources.get(computers[index % computers.length]), 
        boxX, 
        boxY, 
        boxWidth, 
        boxHeight
    );
    
   
    ctx.drawImage(
        resources.get('img/dhs2.png'),
        1 * spriteWidth,
        2 * spriteHeight,
        spriteWidth,
        spriteHeight,
        leftSpriteX - spriteWidth,
        leftSpriteY - spriteHeight / 2,
        spriteWidth,
        spriteHeight
    );

    ctx.drawImage(
        resources.get('img/dhs2.png'),
        x * spriteWidth,
        y * spriteHeight,
        spriteWidth,
        spriteHeight,
        rightSpriteX,
        rightSpriteY - spriteHeight / 2,
        spriteWidth,
        spriteHeight
    );
}

const slider = document.getElementById("slider");

function handleSliderChange() {
    index = parseInt(slider.value) - 1;
}

const button = document.getElementById('state_button');
const iconImage = document.getElementById('iconImage');
const images = ['img/red_heart.png', 'img/purple_heart.png']; // Add paths to your different icon images

let currentIndex = 0;

button.addEventListener('click', function() {
  currentIndex = (currentIndex + 1) % images.length; // Cycle through the images
  iconImage.src = images[currentIndex]; // Change the image source
});

slider.addEventListener("input", handleSliderChange);
</script>
<script>
    class Cell
{
    static width = 10;
    static height = 10;

    constructor (context, gridX, gridY)
    {
        this.context = context;

        this.gridX = gridX;
        this.gridY = gridY;

        this.alive = Math.random() > 0.99;
    }

    draw() {
        if (this.alive)
        {
          this.context.fillStyle = '#7bc99a';
          this.context.fillRect(this.gridX * Cell.width, this.gridY * Cell.height, Cell.width, Cell.height);
        }
    }
}

class GameWorld {

    static numColumns = 75;
    static numRows = 40;

    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.context = this.canvas.getContext('2d');
        this.canvas.width = 500;
        this.canvas.height = 500;

        this.gameObjects = [];

        this.createGrid();

        window.requestAnimationFrame(() => this.gameLoop());
    }

    createGrid()
    {
        for (let y = 0; y < GameWorld.numRows; y++) {
            for (let x = 0; x < GameWorld.numColumns; x++) {
                this.gameObjects.push(new Cell(this.context, x, y));
            }
        }
    }

    isAlive(x, y)
    {
        if (x < 0 || x >= GameWorld.numColumns || y < 0 || y >= GameWorld.numRows){
            return false;
        }

        return this.gameObjects[this.gridToIndex(x, y)].alive ? 1 : 0;
    }

    gridToIndex(x, y){
        return x + (y * GameWorld.numColumns);
    }

    checkSurrounding ()
    {
        for (let x = 0; x < GameWorld.numColumns; x++) {
            for (let y = 0; y < GameWorld.numRows; y++) {

                let numAlive = this.isAlive(x - 1, y - 1) + this.isAlive(x, y - 1) + this.isAlive(x + 1, y - 1) + this.isAlive(x - 1, y) + this.isAlive(x + 1, y) + this.isAlive(x - 1, y + 1) + this.isAlive(x, y + 1) + this.isAlive(x + 1, y + 1);
                let centerIndex = this.gridToIndex(x, y);

                if (numAlive % 2 === 1)
                {
                  this.gameObjects[centerIndex].nextAlive = true;
                }
                else
                {
                  this.gameObjects[centerIndex].nextAlive = false;
                }

                /*if (numAlive == 2)
                {
                    this.gameObjects[centerIndex].nextAlive = this.gameObjects[centerIndex].alive;
                }
                else if (numAlive == 3)
                {
                    this.gameObjects[centerIndex].nextAlive = true;
                }
                else
                {
                    this.gameObjects[centerIndex].nextAlive = false;
                }*/
            }
        }

        for (let i = 0; i < this.gameObjects.length; i++) {
            this.gameObjects[i].alive = this.gameObjects[i].nextAlive;
        }
    }

    gameLoop() {
        this.checkSurrounding();

        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);

        //this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)

        for (let i = 0; i < this.gameObjects.length; i++) {
            this.gameObjects[i].draw();
        }

        setTimeout( () => {
            window.requestAnimationFrame(() => this.gameLoop());
        }, 500)
    }
}

window.onload = () => {
  let gameWorld = new GameWorld('life-canvas');
}
</script>


<nav id="sitenav">
    <div class="sitenav">
        <span class="navlink">
                        <a href="функции-k-значной-логики.html" accesskey="n" rel="previous"><i class="fa-solid fa-angle-left fa-sm" style="color: #363636;"></i></a>
                    </span>
        <span class="navlink">
                        <a href="index.html" accesskey="h" rel="top"><i class="fa-solid fa-book fa-sm" style="color: #363636;"></i></a>
                    </span>
        <span class="navlink">
                    </span>
    </div>
</nav>

</body>
</html>
