---
title: Теория дискретных функций
---

# Булевы функции


:::: {#definition-0}

**Определение:** *Конечный упорядоченный набор* -- это $(a_1, \ldots, a_n), \,\,\,\, a_i \in A_i \,\,\,\, \forall i \in \{1, \ldots, n\}, \,\,\,\, A_1, \ldots, A_n$ -- некоторые множества.

::::

**Упражнение:**<a name="exercise-0"></a> Определите конечный упорядоченный набор используя множества, а не вот эти вот круглые скобочки.

:::: {#definition-1}

**Определение:**  *Прямое произведение* множеств $A_1\times A_2\times\ldots\times A_n = \{(a_1, \ldots, a_n): \,\,\,\, a_i \in A_i\}$.

::::

:::: {#definition-2}

**Определение:**  *Значение* $i$*-ой переменной* -- это $i$-й элемент упорядоченного набора.

::::

:::: {#definition-3}

**Определение:**  $n$*- мерный булев куб* $B_n = \{0, 1\} \times \ldots \times \{0, 1\} = \{0, 1\}^n = \{(x_1, \ldots, x_n): \,\,\,\, x_i \in \{0, 1\}\}$.

::::

:::: {#definition-4}

**Определение:**  *Булева функция* от $n$ переменных -- это $f: \,\,\,\, B_n \to \{0, 1\}$.

::::

:::: {#definition-5}

**Определение:**  Переменная $x_i$ -- *существенная переменная* булевой функции $f$, если $$f(x_1, \ldots, x_{i - 1}, 0, x_{i + 1}, \ldots, x_n) \ne f(x_1, \ldots, x_{i - 1}, 1, x_{i + 1}, \ldots, x_n),$$

::::
иначе переменная $x_i$ -- *фиктивная*.

:::: {#definition-6}

**Определение:**  (*равные функции*) $f \sim g$, если $\exists$ цепочка добавлений и удалений фиктивных переменных, переводящая $f$ в $g$ (может быть $0$ добавлений и удалений).

::::

## Элементарные булевы функции


очевидно

## Формула


:::: {#definition-7}

**Определение:**  *Алфавит* -- это некоторое множество.

::::

:::: {#definition-8}

**Определение:**  *Слово* *длины* $n \in \mathbb{N}$ в некотором алфавите $A$ -- это $\alpha: \,\,\,\, \{0, \ldots, n\} \to A$. При этом $\alpha(1)$ -- *первая буква* ...

::::

Слово длины $0$ обозначается $\Lambda$.

:::: {#definition-9}

**Определение:**  *Алфавит для функций* -- это $(X, S, \{(, , , )\})$, где

::::

$X = \{x_1, x_2, \ldots\}$ -- множество символов переменных.

$S$ -- множество функциональных символов.

$\{(, , , )\}$ -- множество, состоящее из открывающей круглой скобки, закрывающей круглой скобки и запятой :)

:::: {#definition-10}

**Определение:**  *Сигнатура* алфавита для функций -- это отображение $\Sigma: \,\,\,\, S \to P_2$(множество всех булевых функций).

::::

:::: {#definition-11}

**Определение:**  (Синтаксис -- что является формулой)

1. $x_i \in X, \,\,\,\, i \in \mathbb{N}$ -- *формула*.
2. Пусть $s \in S, \,\,\,\, \Sigma(s) \in P_2^n$(множество булевых функций от $n$ переменных). Пусть $\Phi_1, \ldots, \Phi_n$ -- формулы. Тогда $s(\Phi_1, \ldots, \Phi_n)$ -- *формула*.

::::

:::: {#definition-12}

**Определение:**  (Семантика -- какое значение у формулы)

Пусть $\Phi$ формула в сигнатуре $\Sigma$.
Пусть $P = \{x_{i1}, \ldots, x_{it}\}$ множество всех переменных формулы $\Phi$. $\overline{x} = (x_{i1}, \ldots, x_{it})$. $\alpha = (a_1, \ldots, a_t) \in \{0, 1\}^t$.

Тогда значение формулы $\Phi$ на наборе $\alpha$ -- это

1. $\Phi[\overline{x}, \alpha] = a_{j}$, если $\Phi = x_{ij}$.
2. Пусть $\Phi = s(\Phi_1, \ldots, \Phi_n)$. $\Phi[\overline{x}, \alpha] = f(b_1, \ldots, b_n)$, где $b_i = \Phi_i[\overline{x}, \alpha]$.

::::

:::: {#definition-13}

**Определение:**  Формула $\Phi$ *задает* функцию $f$ относительно $P$, если $\forall \alpha \in \{0, 1\}^t \,\,\,\, f(\alpha) = \Phi[\overline{x}, \alpha]$.

::::



# Булевы функции

## Эквивалентные формулы


:::: {#definition-14}

**Определение:**  Формулы $\Phi_1$ и $\Phi_2$, заданные в сигнатуре $\Sigma$ *эквивалентны*, если они задают равные функции относительно объединения своих переменных.

::::

## Основные тождества для элементарных функций алгебры логики



## Двойственность и самодвойственность


:::: {#definition-15}

**Определение:**  Булева функция $f^{*} = \overline{f(\overline{x}_1, \ldots, \overline{x}_n)}$ -- *двойственная* к функции $f$.

::::

:::: {#definition-16}

**Определение:**  Функция $f$ *самодвойственная*, если $f^{*} = f$.

::::

## Принцип двойственности


дичь какая-то

## Совершенная дизъюнктивная нормальная форма


:::: {#definition-17}

**Определение:**  

::::

$$x^{\sigma} = \begin{cases}
    x,\,\,\,\, \sigma = 1\\
    \overline{x},\,\,\,\, \sigma = 0
\end{cases} \,\,\,\,\,\,\,\, \sigma \in \{0, 1\}$$

:::: {#theorem-0}

**Теорема:**  (ДНФ) Пусть $f$ булева функция от $n$ переменных. Тогда 
$$f(x_1, \ldots, x_n) = \displaystyle\bigvee_{(\sigma_1, \ldots, \sigma_m)}x_1^{\sigma_1}\cdot\ldots\cdot x_n^{\sigma_m}f(\sigma_1, \ldots, \sigma_m, x_{m + 1}, \ldots, x_n)$$

*Доказательство:* Пусть $(\alpha_1, \ldots, \alpha_n)$ произвольный двоичный набор. Если $\exists i: \,\,\,\, (\alpha_1, \ldots, \alpha_n) \ne (\sigma_1, \ldots, \sigma_n)$, то $x_1^{\sigma_1}\cdot\ldots\cdot x_n^{\sigma_m}f(\sigma_1, \ldots, \sigma_m, x_{m + 1}, \ldots, x_n)$ на этом наборе $0$. То есть нужно рассматривать только наборы $(\alpha_1, \ldots, \alpha_n) = (\sigma_1, \ldots, \sigma_n)$, для которых $\alpha_1^{\alpha_1}\cdot\ldots\cdot \alpha_n^{\alpha_m}f(\alpha_1, \ldots, \alpha_m, \alpha_{m + 1}, \ldots, \alpha_n) = f(\alpha_1, \ldots, \alpha_n) \,\,\,\,\blacksquare$

::::

:::: {#definition-18}

**Определение:**  *Совершенная дизъюнктивная нормальная форма* -- это правая часть равентва из теоремы при $m = n$.

::::

:::: {#definition-19}

**Определение:**  *Совершенная конъюнктивная нормальная форма* получается из СДНФ для двойственной функции по принципу двойственности (принцип двойственности -- это, конечно, дичь).

::::

## Полная система функций алгебры логики


:::: {#definition-20}

**Определение:**  Система $\{f_1, \ldots, f_n\}$ булевых функций *полна*, если с помощью суперпозиций из нее можно получить любую функцию алгебры логики.

::::

:::: {#statement-0}

**Утверждение:**  Система $\{\overline{x}, x \vee y, x \wedge y\}$ полна.

*Доказательство:* $\,\,\,\,\blacksquare$

::::

:::: {#statement-1}

**Утверждение:**  Пусть система $M$ полна. Если любую функцию из $M$ можно выразить суперпозициями функций из $M’$, то $M’$ полна.

**Утверждение:**<a name="statement-2"></a> Следующие системы полны:

1. $\{\overline{x}, x \vee y\}$
2. $\{x | y\}$
3. $\{x \downarrow y\}$
4. $\{0, 1, x\cdot y, x + y\}$

*Доказательство:* $\,\,\,\,\blacksquare$

::::

## Полином Жегалкина


:::: {#statement-2}

**Утверждение:**  Любая булева функция представима в виде полинома по модулю $2$ единственным образом.

*Доказательство:* Система $\{0, 1, x\cdot y, x + y\}$ полна, а значит любая функция представима полиномом.


Докажем единственность. Посчитаем количество различных полиномов. Количество мономов (произведение некоторых $k < n$ переменных) равно количеству подмножеств множества из $n$ элементов, то есть $2^n$. У каждого монома свободный член либо $0$ либо $1$, то есть получаем $2^{2^n} \,\,\,\,\blacksquare$

::::

## Замыкание множества булевых функций


:::: {#definition-21}

**Определение:**  *Операции суперпозиции* -- это подстановка переменных, подстановка функции, добавление либо удаление несущественных переменных. Функция, полученная из исходной с помощью операций суперпозиции, получена *суперпозициями*.

::::

:::: {#definition-22}

**Определение:**  Пусть $M = \{f_1, \ldots, f_n\}, \,\,\,\, f_i$ -- булева функция. *Замыкание* $M$ -- это множество всех булевых функций, которые можно получить из $M$ суперпозициями. 

::::

**Обозначается:** $[M]$

:::: {#definition-23}

**Определение:**  Система полна, если ее замыкание совпадает с $P_2$.

::::

### Простейшие свойства замыкания


:::: {#statement-3}

**Утверждение:**  Пусть $M, M_1, M_2$ системы булевых функций. Тогда

1. $M \subset [M]$
2. $[\ldots[[[M]]]\ldots] = [M]$
3. Если $M_1 \subset M_2$, то $[M_1] \subset [M_2]$
4. $[M_1] \cup [M_2] \subset [M_1 \cup M_2]$

*Доказательство:* $\,\,\,\,\blacksquare$

::::

:::: {#definition-24}

**Определение:**  Система $M$ булевых функций *замкнута*, если $[M] = M$.

::::

**Пример:** Замыкание любой системы -- замкнутое множество.

## Замкнутость классов $T_0$ и $T_1$


:::: {#definition-25}

**Определение:**  (*функции, сохраняющие* $0$) $T_0 = \{f \in P_2: \,\,\,\, f(0, \ldots, 0) = 0\}$.

::::

:::: {#definition-26}

**Определение:**  (*функции, сохраняющие* $1$) $T_1 = \{f \in P_2: \,\,\,\, f(1, \ldots, 1) = 1\}$.

::::

:::: {#statement-4}

**Утверждение:**  $T_0$ и $T_1$ замкнуты.

*Доказательство:* проверка по пунктам каждой операции суперпозиции $\,\,\,\,\blacksquare$

::::

## Замкнутость класса самодвойственных функций


:::: {#definition-27}

**Определение:**  Множество всех самодвойственных функций обозначается $S$.

::::

:::: {#statement-5}

**Утверждение:**  $S$ замкнут.

*Доказательство:*

::::

### Лемма о несамодвойственной функции


:::: {#statement-6}

**Утверждение:**  Пусть $f$ не является самодвойственной. Тогда суперпозициями из $f$ и $\overline{x}$ можно получить константу.

*Доказательство:* $f \not\in S \Rightarrow \exists (\alpha_1, \ldots, \alpha_n): \,\,\,\, f(\alpha_1, \ldots, \alpha_n) = f(\overline{\alpha}_1, \ldots, \overline{\alpha}_n)$. Пусть $g(x) = f(x^{\alpha_1}, \ldots, x^{\alpha_n})$. Тогда $g(0) = f(0^{\alpha_1}, \ldots, 0^{\alpha_n}) = f(\overline{\alpha}_1, \ldots, \overline{\alpha}_n) = f(\alpha_1, \ldots, \alpha_n) = f(1^{\alpha_1}, \ldots, 1^{\alpha_n}) = g(1) \,\,\,\,\blacksquare$

::::

## Замкнутость класса монотонных функций


:::: {#definition-28}

**Определение:**  Пусть даны два двоичных набора $\tilde{\alpha} = (\alpha_1, \ldots, \alpha_n)$ и $\tilde{\beta} = (\beta_1, \ldots, \beta_n)$. $\tilde{\alpha} \le \tilde{\beta}$, если $\forall i \in \{1, \ldots, n\}\,\,\,\, \alpha_i \le \beta_i$.

::::

:::: {#definition-29}

**Определение:**  Булева функция $f$ *монотонна*, если для любых наборов $\tilde{\alpha}$ и $\tilde{\beta}$, таких, что $\tilde{\alpha} \le \tilde{\beta} \,\,\,\, f(\tilde{\alpha}) \le f(\tilde{\beta})$.

::::

:::: {#definition-30}

**Определение:**  Множество всех монотонных булевых функций обозначается $M$. 

::::

:::: {#statement-7}

**Утверждение:**  Класс $M$ замкнут.

*Доказательство:* 

::::

## Лемма о немонотонной функции


:::: {#statement-8}

**Утверждение:**  Если $f \not\in M$, то суперпозициями из $f$, $0$ и $1$ можно получить $\overline{x}$.

*Доказательство:*

![](img/img.png)

::::

## Замкнутость класса линейных функций


:::: {#definition-31}

**Определение:**  Булева функция $f$ *линейна*, если она представима в виде $c_0 + c_1 x_1 + c_2 x_2 + \ldots + c_n x_n, \,\,\,\, c_i \in \{0, 1\}$.

::::

:::: {#definition-32}

**Определение:**  Множество всех линейных функций обозначается $L$.

::::

:::: {#statement-9}

**Утверждение:**  Класс $L$ замкнут.

*Доказательство:*

::::

## Лемма о нелинейной функции


:::: {#statement-10}

**Утверждение:**  Пусть $f \not\in L$. Тогда из $f$, $\overline{x}$, $0$, $1$ суперпозициями можно получить $x_1 \wedge x_2$.

*Доказательство:* Запишем $f$ полиномом Жегалкина, так как $f \not\in L$ в полиноме есть член степени большей $1$. Пусть он содержит $x_1$ и $x_2$. Тогда

$$f = x_1 x_2 f_1(x_3, \ldots, x_n) + x_1 f_2(x_3, \ldots, x_n) + x_2 f_3(x_3, \ldots, x_n) + f_4(x_3, \ldots, x_n)$$

$f_1$ не тождественный ноль, так как иначе нарушается единственность представления в виде полинома. Значит существует $(\alpha_3, \ldots, \alpha_n): \,\,\,\, f_1(\alpha_3, \ldots, \alpha_n) = 1$.

Рассмотрим $g(x_1, x_2) = f(x_1, x_2, \alpha_3, \ldots, \alpha_n) = x_1 x_2 + \alpha x_1 + \beta x_2 + \gamma$.

$g(x_1 + \beta, x_2 + \alpha) = x_1 x_2 + \beta x_2 + \alpha x_1 + \beta \alpha + \alpha x_1 + \beta x_2 + \gamma = x_1 x_2 + \beta \alpha + \gamma$

$g(x_1 + \beta, x_2 + \alpha) + \beta \alpha + \gamma = x_1 x_2 \,\,\,\,\blacksquare$

**Замечание:** $x + 0 = x \,\,\,\, \overline{x} = x + 1$.

::::

## Различие классов $T_0, T_1, S, M, L$


$$\begin{array}{c|ccccc}
& T_0 & T_1 & S & M & L\\
\hline
0 & + & - & - & + & +\\
1 & - & + & - & + & +\\
\overline{x} & - & - & + & - & +\\
x_1 \wedge x_2 & + & + & - & + & -\\
x_1 + x_2 & + & - & - & - & +\\
x_1 + x_2 + x_3 & + & + & + & - & +\\
x_1 x_2 \vee x_1 x_3 \vee x_2 x_3 & + & + & + & + & -\\
\end{array}$$

## Теорема о полноте систем булевых функций


:::: {#statement-11}

**Утверждение:**  Система булевых функций $F$ полна $\Leftrightarrow$ $F$ не содержится ни в одном из классов $T_0, T_1, S, M, L$.

*Доказательство:* $$\Rightarrow$$

Ни один из классов $[T_0], [T_1], [S], [M], [L]$ не является полным, то есть, если $F$ содержится в одном из них, система $F$ неполна.

$$\Leftarrow$$

$\exists f_{T_0} \not\in T_0, \,\,\,\, f_{T_1} \not\in T_1, \,\,\,\, f_S \not\in S, \,\,\,\, f_M \not\in M, \,\,\,\, f_L \not\in L$.

Докажем существование констант $1$ и $0$.

$f_{T_0}(0, \ldots, 0) = 1$, если $f_{T_0}(1, \ldots, 1) = 1$, то $1 = f_{T_0}(x, \ldots, x)$. Иначе $f_{T_0}(1, \ldots, 1) = 0$, тогда $f_{T_0}(x, \ldots, x) = \overline{x}$, по лемме о несамодвойственной функции из $f_S$ и $\overline{x}$ можно получить константу, если это не $1$, то получим $1$ отрицанием.

Имея $1$, $0$ и $f_M$ получим $\overline{x}$ по лемме.
Имея $\overline{x}$, $0$, $1$ и $f_L$ получим $x_1 \cdot x_2$ по лемме.
Значит имеем полную систему $\{x_1\cdot x_2, \overline{x}\} \,\,\,\,\blacksquare$

::::

## Из любой полной системы булевых функций можно выделить полную систему из четырех функций


:::: {#statement-12}

**Утверждение:**  Из любой полной системы булевых функций можно выделить полную систему из четырех функций.

*Доказательство:* Рассмотрим $f_{T_0} \not\in T_0, \,\,\,\, f_{T_1} \not\in T_1, \,\,\,\, f_S \not\in S, \,\,\,\, f_M \not\in M, \,\,\,\, f_L \not\in L$. Это полная система по теореме. Если $f_{T_0}(1, \ldots, 1) = 1$, то $f_{T_0}$ несамодвойственная, т.к. $f_{T_0}(0, \ldots, 0) = 1$, и значит можем взять ее в качестве $f_S$. Если $f_{T_0}(1, \ldots, 1) = 0$, то $f_{T_0}$ немонотонна, и значит возьмем ее в качестве $f_M \,\,\,\,\blacksquare$

::::

## Предполные классы


:::: {#definition-33}

**Определение:**  Класс булевых функций $F$ *предполный*, если $[F] \ne P_2$ и $\forall f \in P_2 \setminus F \,\,\,\, [F \cup \{f\}] = P_2$.

::::

:::: {#corollary-0}

**Следствие:**  Любой несовпадающий с $P_2$ замкнутый класс булевых функций содержится в одном из классов $T_0, T_1, S, M, L$.

*Доказательство:* Если бы не содержался ни в одном, то был бы полной системой, а так как замкнут совпадал бы с $P_2 \,\,\,\,\blacksquare$

::::

:::: {#statement-13}

**Утверждение:**  Предполный класс $F$ замкнут.

*Доказательство:* Пусть не так. Тогда возьмем $f \in [F] \setminus F$. Имеем $[F \cup \{f\}] = P_2$ и $[F \cup \{f\}] \subset [[F]] = [F] \ne P_2 \,\,\,\,\blacksquare$

::::

:::: {#corollary-1}

**Следствие:**  Предполными классами в $P_2$ являются только классы $T_0, T_1, S, M, L$.

*Доказательство:* Если класс $F$ предполный, то он содержится в одном из классов $T_0, T_1, S, M, L$. Обозначим этот класс $Q$. Пусть $F \ne Q$. Возьмем $f \in Q \setminus F \,\,\,\, [F \cup \{f\}] \subset [F] \ne P_2$. Противоречие.

Докажем, что каждый из классов $T_0, T_1, S, M, L$ предполный. Если это не так, то такой класс содержится в одном из других, а как было показано ни один из классов $T_0, T_1, S, M, L$ в другом не содрежится $\,\,\,\,\blacksquare$

::::


## Полнота относительно замкнутого класса


:::: {#definition-34}

**Определение:**  Пусть класс $F$ замкнут. Система $K$ функций из $F$ *полна в* $F$, если $[K] = F$.  

::::

## Базис замкнутого класса


:::: {#definition-35}

**Определение:**  Пусть класс $F$ замкнут. Система $K \subset F$ -- *базис* в $F$, если $K$ полна в $F$ и $\forall f \in K \,\,\,\, K \setminus f$ неполна в $F$.

::::

## Теоремы Поста о базисе


:::: {#theorem-1}

**Теорема:**  В каждом замкнутом классе существует конечный базис.

*Доказательство:*

::::

:::: {#theorem-2}

**Теорема:** Существует счетное число замкнутых классов.

*Доказательство:*

::::

$\DeclareMathOperator*{\bigplus}{\text{\Huge $+$}}$

# Функции $k$-значной логики


:::: {#definition-36}

**Определение:**  $E_k = \{0, 1, \ldots, k - 1\}$.

::::

:::: {#definition-37}

**Определение:**  $E_k^n = E_k \times \ldots \times E_k$.

::::

:::: {#definition-38}

**Определение:**  $f: E_k \times \ldots \times E_k \to E_k$ -- *функция* $k$ -- *значной логики*.

::::

:::: {#definition-39}

**Определение:**  Множество всех функций $k$ -- значной логики обозначается $P_k$.

::::

## Аналог совершенной дизъюнктивной нормальной формы для $P_k$


:::: {#definition-40}

**Определение:**  (*большая индикаторная функция*) $J_{i}(x) = \begin{cases}k - 1, x = i\\0, x \ne i\end{cases}$

::::

:::: {#statement-14}

**Утверждение:** Любая $f \in P_k$ может быть представлена в виде
$$f(x_1, \ldots, x_n) = \max_{(\sigma_1, \ldots, \sigma_n) \in E_k^n}\{\min(J_{\sigma_1}(x_1),\ldots, J_{\sigma_n}(x_n), f(\sigma_1, \ldots, \sigma_n))\}$$

*Доказательство:* аналогично (тоже мне аналогично) $P_2 \,\,\,\,\blacksquare$

::::

## Полнота в $P_k$


:::: {#definition-41}

**Определение:**  Система функций $k$ -- значной логики *полна*, если с помощью суперпозиций из нее можно получить любую функцию $P_k$.

::::

:::: {#statement-15}

**Утверждение:**  Система $\{0, 1, \ldots, k - 1, J_0(x), J_1(x), \ldots, J_n(x), \max(x, y), \min(x, y)\}$ полна.

*Доказательство:* см. теорему $\,\,\,\,\blacksquare$

::::

## Полнота системы, состоящей из функции Вебба


:::: {#statement-16}

**Утверждение:**  Система $\{\max(x, y), \overline{x}\}$ полна.

*Доказательство:* Будем сводить к системе $\{0, 1, \ldots, k - 1, J_0(x), J_1(x), \ldots, J_n(x), \max(x, y), \min(x, y)\}$.

1. Получим константы. $\overline{x} = x + 1, \overline{\overline{x}} = x + 2, \ldots, \overline{\overline{\dot{\dot{\dot{\overline{x}}}}}} = x + k - 1, \overline{\overline{\dot{\dot{\dot{\overline{x}}}}}} = x$. Рассмотрим функцию $g(x) = \max(x, x + 1, \ldots, x + k - 1)$, так как система $\{x, x+1, \ldots, x+k-1\}$ принимает все значения при подстановке переменной, получаем, что $g(x) = k - 1$. Далее с помощью отрицания Поста получим остальные константы ($0 = \overline{k - 1}$).

2. Получим $J_0(x), J_1(x), \ldots, J_n(x)$. Рассмотрим $\varphi_j(x) = \max(x, x+1, \ldots, x+j-1, x+j+1, \ldots, x+k-1)$. Эта функция принимает значение $k - 2$, если $x + j = k - 1$ и $k - 1$, если $x + j \ne k - 1$. То есть $\overline{\varphi_j(x)} = \varphi_j(x) + 1 = \begin{cases} k - 1,\,\,\,\, x = k - 1 - j \\0,\,\,\,\, x \ne k - 1- j  \end{cases} = J_{k - 1 - j}(x)$. То есть получили все $J_i(x)$.

3. Докажем, что можно получить любую одноместную функцию (нужно, чтобы получить отрицание Лукашевича). $s_{ci}(x) = \max(J_i(x), c) = \begin{cases} k - 1,\,\,\,\, x = i \\ c,\,\,\,\, x \ne i  \end{cases}$. $h_{ci}(x) = s_{ci}(x) + (k - c) = \begin{cases} k - 1 - c, \,\,\,\, x = i \\ 0, \,\,\,\, x \ne i \end{cases}$, то есть получили функцию $f_{pi}$, которая при данном $i$ принимает данное значение $p$ ($p = k - 1 - c$, получаем его меняя $c$).
Пусть $r(x)$ одноместная функция $P_k$. Тогда $r(x) = \max(f_{r(0)0}(0), \ldots, f_{r(x_n)x_n}(0))$. Получили все одноместные функции, в том числе отрицание Лукашевича $\sim x$.

4. $\sim\max(\sim x, \sim y) = \min(x, y) \,\,\,\,\blacksquare$

::::

:::: {#definition-42}

**Определение:**  $V(x, y) = \max(x, y) + 1$ -- *функция Вебба*.

::::

:::: {#statement-17}

**Утверждение:**  Система $\{V(x, y)\}$ полна.

*Доказательство:* $V(x, x) = \max(x, x) + 1 = \overline{x}$, а по предыдущей теореме система $\{\max(x, y), \overline{x}\}$ полна $\,\,\,\,\blacksquare$

::::

## Замкнутые классы и замыкание в $P_k$


:::: {#definition-43}

**Определение:**  Пусть $F$ система функций $k$-значной логики. *замыкание* $F$ -- это множество всех функций из $P_k$, которые можно получить суперпозициями из функций $F$. Обозначается: $[F]$.

::::

:::: {#definition-44}

**Определение:**  Система $F$ функций $k$-значной логики *замкнута*, если $[F] = F$.

::::

:::: {#definition-45}

**Определение:**  Функция $k$-значной логики $f$ *сохраняет множество* $U \subset E_k$, если $\forall \alpha_1, \ldots, \alpha_n \in U \,\,\,\, f(\alpha_1, \ldots, \alpha_n) \in U$.

::::

:::: {#statement-18}

**Утверждение:**  Система $\{\sim x, \max(x, y)\}$ при $k \ge 3$ неполна.

*Доказательство:* Рассмотрим $U = \{0, k - 1\}$. $\sim (k - 1) = 0, \,\,\,\, \sim 0 = k - 1 \Rightarrow$ $\sim x$ и $\max(x, y)$ сохраняют $U$, а значит исходная система неполна $\,\,\,\,\blacksquare$

::::

## Алгоритм распознавания замкнутости системы в $P_k$


:::: {#definition-46}

**Определение:**  Пусть задан алфавит $(X, S)$ с сигнатурой $\Sigma$. *Глубина формулы* $\Phi \,\,\,\, \operatorname{depth}(\Phi)$ равна

1. $0$, если $\Phi \in X$.
2. Пусть $\Phi_1, \ldots, \Phi_n$ формулы, у которых известна глубина. Тогда глубина формулы $s(\Phi_1, \ldots, \Phi_n), s \in S$ равна $\max\{\operatorname{depth}(\Phi_1), \ldots, \operatorname{depth}(\Phi_n)\} + 1$.

::::

:::: {#definition-47}

**Определение:**  Пусть дано множество функций $k$-значной логики $F$. *Последовательность Кузнецова* системы $F$ -- это последовательность классов $G_0, G_1, \ldots$, где $G_i$ состоит из всех функций $k$-значной логики от двух переменных, таких, что глубина соответствующих им формул не превосходит $i$.

::::

:::: {#statement-19}

**Утверждение:**  Пусть дано множество функций $k$-значной логики $F$. Последовательность Кузнецова для $F$ - $G_0, G_1, \ldots$ Тогда 

1. $\varnothing = G_0 \subset G_1 \subset \ldots \subset G_{s} \subset \ldots$
2. Для некоторого $s \,\,\,\, G_0 \subset \ldots \subset G_s = G_{s + 1} = \ldots = G$.

*Доказательство:* 

1. $\,\,\,\,\blacksquare$
2. Количество функций $k$-значной логики от $2$-ух переменных равно $k^{k^2} \,\,\,\,\blacksquare$

::::

:::: {#definition-48}

**Определение:**  *Предел последовательности Кузнецова* -- это $G$.

::::


:::: {#theorem-3}

**Теорема:**  Пусть дано множество функций $k$-значной логики $F$. $F$ полна $\Leftrightarrow$ предел последовательности Кузнецова для $F$ содержит функцию Вебба.

*Доказательство:* Свяжем с каждой функцией последовательности Кузнецова для $F$ формулу в сингнатуре $\Sigma$, содержащую только переменные $x_1$ и $x_2$. Пусть $\{\Phi_1, \ldots, \Phi_n\}$ все формулы, соответствующие фунциям из $G_i$. Рассмотрим $s(\Phi_1, \ldots, \Phi_k)$ и функцию $f$, задаваемую этой формулой. Если среди $\Phi_1, \ldots, \Phi_k$ есть формула глубины $i$, то глубина $s(\Phi_1, \ldots, \Phi_k)$ равна $i + 1$, то есть $f \in G_{i + 1}$.

Рассмотрим функцию $f \in G_{i + 1} \setminus G_i$. $\operatorname{depth}f = i + 1$, а значит $f$ определяется формулой $s(\Phi_1, \ldots, \Phi_n)$, где каждая из формул $\Phi_i$ либо переменная, либо задает функцию $g_i$, принадлежащую $G_i$, а такая функция представляется в $G_i$ некоторой формулой $\Phi_i’$, и, заменив в $s(\Phi_1, \ldots, \Phi_n)$ $\Phi_i$ на $\Phi_i’$ получим эквивалентную $s(\Phi_1, \ldots, \Phi_n)$ формулу.

А значит по $G_i$ можем построить $G_{i + 1}$.

Теперь пусть функция Вебба принадлежит $G$. Тогда она получается суперпозициями из $F$, а следовательно $F$ полна.

Пусть $F$ полна. Тогда функция Вебба задается в сигнатуре $\Sigma$ формулой, имеющей две существенные переменные, а значит принадлежит некоторому $G_i \subset G \,\,\,\,\blacksquare$

::::

## Селекторные функции


:::: {#definition-49}

**Определение:**  $g^p_i(x_1, \ldots, x_p) \,\,\,\, g^p_i(\alpha_1, \ldots, \alpha_p) = \alpha_i$ -- *селекторная функция* от $p$ переменных.

::::

## Сохранение множества $К$, включающего селекторные функции


:::: {#definition-50}

**Определение:**  Пусть $K$ содержит все селекторные функции от $p$ переменных и некоторый набор функций от $p$ переменных. Функция $f(x_1, \ldots, x_n)$ *сохраняет* $K$, если $\forall h_1, \ldots, h_n, \,\,\,\, h_i \in K \,\,\,\, f(h_1(x_1, \ldots, x_p), \ldots, h_n(x_1, \ldots, x_p)) \in K$.

::::

:::: {#definition-51}

**Определение:**  Пусть $K$ содержит все селекторные функции от $p$ переменных и некоторый набор функций от $p$ переменных. Множество всех функций, сохраняющих $K$, обозначается $U[K]$.

::::

## Описание класса $S$, как класса сохранения некоторого множества $К$


:::: {#statement-20}

**Утверждение:**  Пусть $k = 2$, $p = 1$, $K = \{x, \overline{x}\}$ ($x$ единственная селекторная функция от $1$ переменной). Тогда $U[K] = S$($S$ множество самодвойственных функций).

*Доказательство:* Пусть $f$ сохраняет $K$. Рассмотрим $f(x_1^{\sigma_1}, \ldots, x_n^{\sigma_n}), \sigma_i \in \{0, 1\}$ (через $x^{\sigma}$ обозначаем $x$, если $\sigma = 1$ и $\overline{x}$, если $\sigma = 0$).

$f(1^{\sigma_1}, \ldots, 1^{\sigma_n}) = 1^{\sigma} \Leftrightarrow f(\sigma_1, \ldots, \sigma_n) = \sigma$

$f(0^{\sigma_1}, \ldots, 0^{\sigma_n}) = 0^{\sigma} \Leftrightarrow f(\overline{\sigma}_1, \ldots, \overline{\sigma}_n) = \overline{\sigma}$, то есть $f(\sigma_1, \ldots, \sigma_n) = \overline{f(\overline{\sigma}_1, \ldots, \overline{\sigma}_n)} \Leftrightarrow f \in S \,\,\,\,\blacksquare$

::::

## Замкнутость класса $U[K]$ всех функций, сохраняющих $К$


:::: {#statement-21}

**Утверждение:**  Пусть $K$ содержит все селекторные функции от $p$ переменных и некоторый набор функций от $p$ переменных. Тогда $U[K]$ замкнут.

*Доказательство:* $\,\,\,\,\blacksquare$

::::

## Неполнота системы $F$, содержащейся в $U[K]$, если функция Вебба не принадлежит $K$


:::: {#statement-22}

**Утверждение:**  Пусть $K$ содержит все селекторные функции от $p$ переменных, некоторый набор функций от $p$ переменных и не содержит функцию Вебба. Если система $F \subset U[K]$, то $F$ неполна.

*Доказательство:* Рассмотрим последовательность Кузнецова для $F: \,\,\,\, G_0, G_1, \ldots$.

Докажем по индукции, что $G_i \subset U[K]$, если $F \subset U[K]$.
База: $G_0 = \varnothing \subset U[k]$.
Пусть $G_i \subset U[K]$. $f \in G_{i + 1} \setminus G_i$. Тогда $f$ соответствует формуле $\Phi = s(\Phi_1, \ldots, \Phi_n)$, где $\Phi_j$ либо переменная $x_1$, либо переменная $x_2$, либо функция $h_j(x_1, x_2)$, глубина формулы которой не больше $i$, то есть $h_j(x_1, x_2) \in K$. Если $\Phi_j$ переменная $x_1$, то скажем, что $h_j(x_1, x_2) = g_1^2(x_1, x_2)$ (это не квадрат, а селекторная функция от $2$ переменных), аналогично с $x_2$. $f(x_1, x_2) = s(h_1(x_1, x_2), \ldots, h_n(x_1, x_2))$, где каждая из $h_j \in K$, то есть $f \in K \,\,\,\,\blacksquare$

::::

## Существование для неполной системы $F$ такого множества $K$, что функция Вебба не принадлежит $K$


:::: {#statement-23}

**Утверждение:**  Если система $F$ неполна, то существует такое множество $K$, содержащее $g_1^2(x_1, x_2), \,\,\,\, g_2^2(x_1, x_2)$, некоторые функции от двух переменных и не содержащее функцию Вебба, такое, что $F \subset U[K]$.

*Доказательство:* Пусть $G_0 \subset G_1 \subset \ldots \subset G_m = G_{m + 1} = \ldots = G$ последовательность Кузнецова для $F$. Пусть $K = G_m \cup \{g_1^2(x_1, x_2), g_2^2(x_1, x_2)\}$. Далее аналогично предыдущему утверждению в обратную сторону $\,\,\,\,\blacksquare$

::::

## Теорема Кузнецова о полноте в $P_k$


:::: {#theorem-4}

**Теорема:**  В $P_k$ можно выбрать такие не содержащиеся друг в друге замкнутые классы $M_1, \ldots, M_n$, что система функций $F$ полна тогда и только тогда, когда $F$ не содержится ни в одном из классов $M_1, \ldots, M_n$.

*Доказательство:* Пусть $U[K_1], \ldots, U[K_s]$ все классы, такие, что $K_i$ -- содержит $g_1^2(x_1, x_2), \,\,\,\, g_2^2(x_1, x_2)$, некоторые функции от двух переменных и не содержит функцию Вебба. Тогда по утверждениям 1 и 2 имеем: $F$ полна эквивалентно тому, что $F$ не содержится ни в одном из $U[K_1], \ldots, U[K_s]$. Выкинув из $U[K_1], \ldots, U[K_s]$ классы, которые содержатся друг в друге, получим искомые предполные классы $\,\,\,\,\blacksquare$

::::

## Существенная функция в $P_k$


:::: {#definition-52}

**Определение:**  Функция $f$ $k$-значной логики *существенная*, если она существенно зависит более чем от одной переменной.

::::

## Лемма С.В.Яблонского о трех наборах


:::: {#lemma-0}

**Лемма:**  Пусть $f(x_1, \ldots, x_n)$ существенная функция в $P_k$, принимающая $l$ значений($l \ge 3$). Пусть $x_1$ существенная переменная $f$. Тогда существуют такие наборы $(\alpha, \alpha_2, \ldots, \alpha_n), \,\,\,\, (\beta, \alpha_2, \ldots, \alpha_n), \,\,\,\, (\alpha, \gamma_2, \ldots, \gamma_n)$, что $f$ принимает на них различные значения.

*Доказательство:* Так как $x_1$ существенная, на наборах $(0, \alpha_2, \ldots, \alpha_n), \ldots, (k- 1, \alpha_2, \ldots, \alpha_n)$ функция $f$ принимает хотя бы два различных значения. Пусть она принимает $l$ значений.

1. $l \le k$. Рассмотрим набор $(\alpha, \gamma_2, \ldots, \gamma_n)$, на котором функция $f$ принимает значение отличное от значений, принимаемых на наборах $(0, \alpha_2, \ldots, \alpha_n), \ldots, (k - 1, \alpha_2, \ldots, \alpha_n)$. $f(\alpha, \gamma_2, \ldots, \gamma_n) \ne f(\alpha, \alpha_2, \ldots, \alpha_n)$. Так как $(\alpha, \gamma_2, \ldots, \gamma_n)$ не принадлежит последовательности, и значений в последовательности не меньше $2$ существует $\beta$, такое, что $f(\beta, \alpha_2, \ldots, \alpha_n) \ne f(\alpha, \gamma_2, \ldots, \gamma_n)$.

2. $\,\,\,\,\blacksquare$

::::

## Лемма о подмножестве, на котором функция принимает $l$ значений


:::: {#lemma-1}

**Лемма:**  Пусть $f(x_1, \ldots, x_n)$ существенная функция в $P_k$, принимающая $l$ значений($l \ge 3$). Пусть $x_1$ существенная переменная $f$. Тогда существуют $G_1, \ldots, G_n, \,\,\,\, G_i \subset E_k,\,\,\,\, 1 \le |G_i| \le l - 1$, такие, что на множестве $G_1 \times \ldots \times G_n$ функция $f$ принимает $l$ значений.

*Доказательство:* По лемме существуют три набора $(\alpha, \alpha_2, \ldots, \alpha_n), \,\,\,\, (\beta, \alpha_2, \ldots, \alpha_n), \,\,\,\, (\alpha, \gamma_2, \ldots, \gamma_n)$, такие, что $f$ принимает на них различные значения. Пусть $(\delta_{i1}, \ldots, \delta_{in})$ -- наборы, на которых функция $f$ принимает остальные $l - 3$ значения ($i \in \{1, \ldots, l - 3\}$).

Пусть $G_i$ -- это объединение $i$-х элементов этих наборов, то есть $G_1 = \{\alpha, \beta, \delta_{11}, \ldots, \delta_{l - 3, 1}\} \,\,\,\,\blacksquare$

::::

## Квадрат в $P_k$


:::: {#definition-53}

**Определение:**  *Квадрат* в $k$-значной логике -- это $4$ набора $(\alpha_1, \ldots, \alpha_{i - 1}, x, \alpha_{i + 1}, \ldots, \alpha_{j - 1}, y, \alpha_{j + 1}, \ldots, \alpha_n), \,\,\,\, x \in \{p_1, p_2\}, \,\,\,\, y \in \{q_1, q_2\}$.

::::

## Лемма о квадрате


:::: {#statement-24}

**Утверждение:**  Пусть $f(x_1, \ldots, x_n)$ существенная функция в $P_k$, принимающая $l$ значений($l \ge 3$). Пусть $x_1$ существенная переменная $f$. Тогда существует квадрат, на одном наборе которого функция $f$ принимает значение отличное от значений на остальных наборах.

*Доказательство:* Записать последовательность пар, заменяя $\gamma$ в тройке из леммы о трех значениях 

$$\{(\alpha, \alpha_2, \ldots, \alpha_n), (\beta, \alpha_2, \ldots, \alpha_n)\}$$
$$\{(\alpha, \gamma_2, \ldots, \alpha_n), (\beta, \gamma_2, \ldots, \alpha_n)\}$$
$$\vdots$$
$$\{(\alpha, \gamma_2, \ldots, \gamma_n), (\beta, \gamma_2, \ldots, \gamma_n)\}$$

Далее порассуждать и понять, что на каких-то соседних строчках функция будет принимать $3$ различных значения $\,\,\,\,\blacksquare$

::::

## Теорема Слупецкого


:::: {#theorem-5}

**Теорема:**  (*критерий Слупецкого*) Пусть система $F$ из $P_k$ содержит все функции одной переменной. Тогда

$F$ полна $\Leftrightarrow F$ содержит существенную функцию, принимающую все $k$ значений.

*Доказательство:* $$\Rightarrow$$

$F$ полна. Пусть $F$ не содержит существенную функцию, принимающую все $k$ значений. Докажем, что суперпозициями нельзя получить существенную функцию из такой системы:

1. Подстановка переменных. Пусть $f(x_1, \ldots, x_n)$ существенно зависит от $1$ переменной. Тогда $g(x_1, \ldots, x_n) = f(x_{i1}, \ldots, x_{in})$ не может иметь более одного существенного значения.

2. Подстановка функции.

3. Добавление и удаление несущественных переменных.

Таким образом, нельзя получить существенную функцию, принимающую все $k$ значений, а значит система неполна $\,\,\,\,\blacksquare$

$$\Leftarrow$$

Докажем по индукции по $l \le k$, что можно получить все функции, принимающие $l$ значений. Пусть $f$ существенная функция из $F$, принимающая все $k$ значений.

**База**: докажем, что могут быть получены все функции, принимающие $2$ значения. По лемме о квадрате существуют $4$ набора $(\alpha_1, \ldots, \alpha_{i - 1}, x, \alpha_{i + 1}, \ldots, \alpha_{j - 1}, y, \alpha_{j + 1}, \ldots, \alpha_n), \,\,\,\, x \in \{p_1, p_2\}, \,\,\,\, y \in \{q_1, q_2\}$ такие, что на одном из них (пусть это будет $(p_1, q_1)$) функция принимает значение $a$ отличное от значений на других. Рассмотрим функцию $\varphi_0(x) = \begin{cases}
    0, \,\,\,\, x = a\\
    1, \,\,\,\, x \ne a
\end{cases}$ -- это функция одной переменной, поэтому она принадлежит $F$. $g(x_1, x_2) = \varphi_0(f(\alpha_1, \ldots, \alpha_{i - 1}, x_1, \alpha_{i + 1}, \ldots, \alpha_{j - 1}, x_2, \alpha_{j + 1}, \ldots, \alpha_n)) = \begin{cases}
    0, \,\,\,\, x_1 = p_1, \,\,\,\, x_2 = q_1\\
    1, 
\end{cases}$. Рассмотрим функции
$\varphi_1(x) = \begin{cases}
    p_1, x = 0\\
    0, x \ne 0
\end{cases}$ и
$\varphi_2(x) = \begin{cases}
    q_1, x = 0\\
    0, x \ne 0
\end{cases}$. Тогда $g’(x_1, x_2) = g(\varphi_1(x_1), \varphi_2(x_2)) = \begin{cases}
    0, x_1 = x_2 = 0\\
    1, 
\end{cases}$. Если предполагать, что $g’(x_1, x_2)$ принимает только значения $0$ и $1$, то $g’(x_1, x_2)$ -- дизъюнкция. Обозначим ее $\vee_{01}$.

$j_0(x) = \begin{cases}
    1, x = 0\\
    0, x \ne 0
\end{cases}$ -- отрицание при ограничении значений на $\{0, 1\}$. Тогда $g’’(x_1, x_2) = j_0(j_0(x_1) \vee_{01} j_0(x_2))$ -- конъюнкция. Обозначим ее $\&_{01}$.

Запишем аналог ДНФ для $P_k: \,\,\,\, h(x_1, \ldots, x_n) = \displaystyle\bigvee_{(\sigma_1, \ldots, \sigma_n)}j_{\sigma_1}(x_1)\& \ldots \& j_{\sigma_n}(x_n)\& f(\sigma_1, \ldots, \sigma_n)$, где $\vee$ -- максимум, $\&$ -- минимум. Пусть $h$ принимает только значения $\{0, 1\}$. Тогда можем заменить $\&$ на $\&_{01}$ и $\vee$ на $\vee_{01}$. Следовательно получили любую функцию, принимающую два значения. База доказана.

**Шаг индукции**. Пусть функция, принимающая $l - 1$ значение может быть получена суперпозициями над $F$. Докажем для функций, принимающих $3 \le l \le k$ значений. По лемме существуют такие $G_1, \ldots, G_n$, что на них $f$ принимает $l$ значений. Пусть эти значения $a_1, \ldots, a_l$, а наборы, на которых эти значения достигаются $a_1: (a_{11}, \ldots, a_{1n}), \ldots, a_l: (a_{l1}, \ldots, a_{ln})$, причем $(a_{1i}, \ldots, a_{li}) \in G_i$ и состоит из $l - 1$ числа. 

Пусть $h(x_1, \ldots, x_m)$ принимает только значения $a_1, \ldots, a_l$. Хотим $h(x_1, \ldots, x_m) = f(\psi_1(x_1, \ldots, x_m), \ldots, \psi_n(x_1, \ldots, x_m))$, причем, чтобы $\psi_i$ принимали не более $l - 1$ значения (тогда по предположению индукции они могут быть получены суперпозициями). Пусть $h(\alpha_1, \ldots, \alpha_m) = a_i$, определим значения на функциях $\psi_j(\alpha_1, \ldots, \alpha_m) = a_{ij}$. Имеем: $f(\psi_1(\alpha_1, \ldots, \alpha_m), \ldots, \psi_n(\alpha_1, \ldots, \alpha_m)) = f(a_{i1}, \ldots, a_{in}) = a_i = h(\alpha_1, \ldots, \alpha_m)$.

Таким образом, определили значение $\psi_j$ на любом наборе, а так как $|\{a_{1i}, \ldots, a_{li}\}| = l - 1$ функции $\psi_j$ принимают не более $l - 1$ значения, то есть по предположению индукции могут быть получены суперпозициям над $F$.

Пусть $h$ принимает значения $b_1, \ldots, b_l$. Пусть $\psi(x) = \begin{cases}
    b_1, x = a_1\\
    \vdots\\
    b_l, x = a_l
\end{cases}$. Тогда $h(x_1, \ldots, x_n) = \psi(h’(x_1, \ldots, x_n))$, где $h’$ принимает значения $a_i$, если $h$ принимает значение $b_i \,\,\,\,\blacksquare$

::::


## Замечание С.В.Яблонского о возможности сужения множества одноместных функций


:::: {#statement-25}

**Утверждение:**  Пусть система $F$ из $P_k$ содержит все функции одной переменной, принимающие не более $k - 1$ значения. Тогда

$F$ полна $\Leftrightarrow F$ содержит существенную функцию.

*Доказательство:* см.выше $\,\,\,\,\blacksquare$

::::

## Теорема Мартина


:::: {#definition-54}

**Определение:**  Функция $f$ $k$-значной логики *шефферова*, если $[\{f\}] = P_k$.

::::

:::: {#theorem-6}

**Теорема:**  (Мартин) Функция $f$ $k$-значной логики шефферова $\Leftrightarrow f$ порождает все функции одной переменной, принимающие не более $k - 1$ значения.

*Доказательство:* $$\Rightarrow$$

$$\Leftarrow$$
Пусть $f$ не является существенной, то есть существенно зависит от $1$ или $0$ переменных ($0$ невозможен, т.к. порождает функции от одной переменной, то есть не константа), ($1$ невозможен, т.к. ...). $\,\,\,\,\blacksquare$

::::

## Теорема Янова


:::: {#definition-55}

**Определение:**  Базис системы функций $F$ $k$-значной логики -- это подмножество $U \subset F$, такое, что $[U] = F$ и $\forall f \in U \,\,\,\, [U \\ \{f\}] \ne F$.

::::

:::: {#theorem-7}

**Теорема:**  (Янов) В $P_k, \,\,\,\, k \ge 3$ существует замкнутый класс, не содержащий базиса.

*Доказательство:* Пусть $f_0 = 0, f_1(x_1) = \begin{cases}
    1, x_1 = 2\\
    0, x_1 \ne 2
\end{cases}, \ldots, f_i(x_1, \ldots, x_i) = \begin{cases} 1, x_1 = \ldots = x_i = 2\\0,  \end{cases}$. Рассмотим $M = [\{f_0, f_1, \ldots\}]$. Далее происходит $\operatorname{magic} \,\,\,\,\blacksquare$

::::
 
## Теорема Мучника


:::: {#theorem-8}

**Теорема:**  (Мучник) В $P_k, \,\,\,\, k \ge 3$ существует замкнутый класс, имеющий счетный базис.

*Доказательство:*

::::


## Представление функций в $P_k$ полиномами


:::: {#theorem-9}

**Теорема:**  Система полиномов по модулю $k$ в $P_k$ полна $\Leftrightarrow$ $k$ -- простое.

*Доказательство:* Записав $2$ форму для функции $k$-значной логики, понимаем, что достаточно рассмотреть представимость $j_0(x)$ полиномом.

1. $k$ -- простое. Тогда $x^{k - 1} \equiv 1 \,\, \mod k \Rightarrow j_0(x) = 1 - x^{k - 1}$.

2. $k = k_1 \cdot k_2, \,\,\,\, k_1, k_2 \in \mathbb{N}$. Пусть $j_0(x) = b_0 + b_1 x + \ldots + b_s x^s$. $j_0(0) = 1 = b_0$. $j_0(k_1) = 0 = 1 + b_1 k_1 + \ldots + b_s k_1^s \,\,\mod k \Rightarrow 1 = n k_1 k_2 - b_1 k_1 - \ldots - b_s k_1^s \,\,\,\,\blacksquare$

::::

# Абстрактный конечный автомат

<style>
img#inv {
    display: none;
}
    /********** Range Input Styles **********/
/*Range Reset*/
input[type="range"] {
   -webkit-appearance: none;
    appearance: none;
    background: transparent;
    cursor: pointer;
    width: 90%;
    margin-bottom: 3rem;
}

/* Removes default focus */
input[type="range"]:focus {
  outline: none;
}

/***** Chrome, Safari, Opera and Edge Chromium styles *****/
/* slider track */
input[type="range"]::-webkit-slider-runnable-track {
   background-color: #55C1A7;
   border-radius: 0.125rem;
   height: 0.25rem;  
}

/* slider thumb */
input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none; /* Override default look */
   appearance: none;

   /*custom styles*/
   background-color: #55C1A7;
   margin-top: -0.875rem;
   height: 2rem;
   width: 2rem;
   border-radius: 1rem;
}

/******** Firefox styles ********/
/* slider thumb */
input[type="range"]::-moz-range-thumb {
   border: none; /*Removes extra border that FF applies*/
   border-radius: 0; /*Removes default border-radius that FF applies*/

   /*custom styles*/
   background-color: #55C1A7;
   margin-top: -1rem;
   height: 2rem;
   width: 2rem;
   border-radius: 1rem;
}

button {
    -webkit-appearance: none;
    appearance: none;
    background: transparent;
    border: none;
}
</style>

## Способы задания


<center>
<button id="state_button" class="icon-button">
  <img id="iconImage" src="img/red_heart.png" alt="Icon">
</button>
</center>
<center><canvas id="main-canvas"></canvas></center>
<center><div id="slider-div"><input type="range" id="slider" min="1" max="20" value="1"></div></center>


Пускай есть машина, которая получает $a$ на вход и выдает $b$. Скучно. Пускай теперь есть много машин (ну или разные состояния одной) и известно в какой момент времени какая машина работает (в каком состоянии находится машина), причем, что очень важно, состояние в следующий момент времени определяется состоянием в текущий и (возможно) входом $a$ (слайдер отвечает за время).

:::: {#definition-56}

**Определение:**  *(Конечный абстрактный детерминированный) автомат* -- это $(A, Q, B, \varphi, \psi)$, где<br><br> $A$ -- *алфавит(множество) входов*.<br><br> $Q$ -- *алфавит(множество) состояний*.<br><br> $B$ -- *алфавит(множество) выходов*.<br><br>Множества $A, Q, B$ -- конечны.<br><br> $\varphi: Q\times A \to Q$ -- *функция переходов*.<br><br> $\psi: Q \times A \to B$ -- *функция выходов*.<br><br>

::::

<center>**Алфавит входов**</center>

<center><canvas id="heart-table-canvas"></canvas></center>

<center>**Алфавит состояний**</center>

<center><canvas id="table-canvas"></canvas></center>

<center>**Алфавит выходов**</center>

<center><canvas id="diam-table-canvas"></canvas></center>

:::: {#definition-57}

**Определение:**  Пусть $(A, Q, B, \varphi, \psi)$ -- автомат. Если $\varphi$ зависит от $a \in A$ фиктивно, то $(A, Q, B, \varphi, \psi)$ -- *автомат Мура*.

::::

:::: {#definition-58}

**Определение:**  Пусть $(A, Q, B, \varphi, \psi)$ -- автомат. Если $A = A_1 \times \ldots \times A_m$, то $(A, Q, B, \varphi, \psi)$ *имеет* $m$ *входов*.

::::

:::: {#definition-59}

**Определение:**  Пусть $(A, Q, B, \varphi, \psi)$ -- автомат. Если $B = B_1 \times \ldots \times B_m$, то $(A, Q, B, \varphi, \psi)$ *имеет* $m$ *выходов*.

::::

### Диаграмма Мура


<center><canvas id="diagram-canvas"></canvas></center>


## Вспомогательные функции для автомата


:::: {#definition-60}

**Определение:**  Пусть $(A, Q, B, \varphi, \psi)$ -- автомат.

Слова в алфавите $A$ -- *входные слова*.

Слова в алфавите $B$ -- *выходные слова*.

Пусть $\alpha$ -- слово. $A$ -- алфавит.

**Обозначения:**

$|\alpha|$ -- длина слова.

$[\alpha]_l$ -- первые $l$ букв слова $\alpha$.

$\Lambda$ -- пустое слово.

$A^{*}$ -- множество всех слов в алфавите $A$.

$\alpha^k$ -- это слово, составленное из записанного $k$ раз слова $\alpha$.

::::

### Доопределение функций входа и состояний


Пусть $(A, Q, B, \varphi, \psi)$ -- автомат. $q \in Q$, $a \in A$, $\alpha$ -- слово в алфавите $A$. Доопределим функции $\varphi$ и $\psi$, так чтобы они могли принимать на вход целые слова.

$\begin{array}{c}
    \varphi(q, \Lambda) = q\\
    \varphi(q, \alpha a) = \varphi(\varphi(q, \alpha), a)
\end{array}$

$\psi(q, \alpha a) = \psi(\varphi(q, \alpha), a)$ (Только непустое входное слово, так как для выхода нужен вход)

:::: {#statement-26}

**Утверждение:**  
$$\varphi(q, \alpha_1 \alpha_2) = \varphi(\varphi(q, \alpha_1), \alpha_2)$$
$$\psi(q, \alpha_1 \alpha_2) = \psi(\varphi(q, \alpha_1), \alpha_2)$$

*Доказательство:* индукция $\,\,\,\,\blacksquare$

::::

:::: {#definition-61}

**Определение:**  Пусть $(A, Q, B, \varphi, \psi)$ -- автомат. $q \in Q$, $\alpha$ -- слово в алфавите $A$.

$\overline{\varphi}(q, \alpha) = \varphi(q, [\alpha]_0)\varphi(q, [\alpha]_1)\ldots \varphi(q, \alpha)$ -- *слово состояний*.

$\overline{\psi}(q, \alpha) = \psi(q, [\alpha]_0)\psi(q, [\alpha]_1)\ldots \psi(q, \alpha)$ -- *слово выходов*.

::::

:::: {#definition-62}

**Определение:**  Пусть $(A, Q, B, \varphi, \psi)$ -- автомат. Зафиксируем $q_1 \in Q$. Тогда $\psi: A^{*} \to B^{*}$. $V_{q_1} = (A, Q, B, \varphi, \psi, q_1)$ -- *инициальный конечный автомат*.

Отображение $f(\alpha) = \overline{\psi}(q_1, \alpha)$ -- *ограниченно-детерминированная функция*.

::::

### Канонические уравнения инициального автомата


:::: {#definition-63}

**Определение:**  Пусть $V_{q_1} = (A, Q, B, \varphi, \psi, q_1)$ -- инициальный атомат. $\alpha$ -- слово в алфавите $A$.

$\mathcal{Q} = \overline{\varphi}(q_1, \alpha)$ -- слово состояний.

$\beta = \overline{\psi}(q_1, \alpha)$ -- слово выходов.

$\begin{cases}
  \mathcal{Q}(1) = q_1\\
  \mathcal{Q}(t + 1) = \varphi(\mathcal{Q}(t), \alpha(t))\\
  \beta(t) = \psi(\mathcal{Q}(t), \alpha(t))
\end{cases}$ -- *канонические уравнения инициального автомата*.

::::


:::: {#statement-27}

**Утверждение:**  

$$\overline{\psi}(q, \alpha_1 \alpha_2) = \overline{\psi}(q, \alpha_1)\overline{\psi}(\varphi(q, \alpha_1), \alpha_2)$$

*Доказательство:* индукция $\,\,\,\,\blacksquare$

::::

## Автоматы в $P_2$


Пусть $A = \underbrace{E_2 \times \ldots \times E_2}_{m}$, 

$Q = \underbrace{E_2 \times \ldots \times E_2}_{n}$,

$B = \underbrace{E_2 \times \ldots \times E_2}_{p}$.

Пусть $\alpha$ -- слово в $A$. Тогда $\alpha$ можно записать, как $\alpha(t) = (a_1(t), \ldots, a_m(t))$.

$\mathcal{Q}(t) = (q_1(t), \ldots, q_n(t))$.

$\beta(t) = (b_1(t), \ldots, b_p(t))$.

$q_1 = (q_{11}, \ldots, q_{1n})$.

Запишем канонические уравнения<a name="canon-p2"></a>:

$$\begin{cases}
  q_i(1) = q_{1i}\\
  q_i(t + 1) = \varphi_i(q_1(t), \ldots, q_n(t), a_1(t), \ldots, a_m(t))\\
  b_j(t) = \psi_j(q_1(t), \ldots, q_n(t), a_1(t), \ldots, a_m(t))
\end{cases}$$

## Автоматы и бесконечные слова


:::: {#definition-64}

**Определение:**  Пусть $A$ -- алфавит. Пусть дано отображение $\alpha: \mathbb{N} \to A$. $\alpha(1)\alpha(3)\ldots$ -- *бесконечное слово*.

Множество всех бесконечных слов обозначается $A^{\infty}$.

::::

Пусть $V_q = (A, Q, B, \varphi, \psi, q)$ -- инициальный автомат. $\alpha$ -- бесконечное слово в $A$.

$\beta = \overline{\psi}(q, \alpha): \mathbb{N} \to B$

$\beta(i) = \psi(q, \alpha(1)\ldots \alpha(i))$.

:::: {#definition-65}

**Определение:**  Пусть $\alpha(1)\alpha(3)\ldots$ -- бесконечное слово. Если существуют $\tau, \tau’ \in \mathbb{N}$, такие, что $\alpha(i + \tau) = \alpha(i) \,\,\,\, \forall i > \tau’ + 1$, то $\tau$ -- *период* $\alpha$, $\tau’$ -- *предпериод*. 

::::

:::: {#theorem-10}

**Теорема:**  Конечный инициальный автомат, имеющий $n$ состояний, преобразует последовательность (бесконечное слово) $\alpha$ с наименьшим периодом $\tau$ в последовательность $\beta$ с наименьшим периодом вида $\theta \cdot m$, где $\theta \,\,|\,\, \tau$ и $m \in \{1, \ldots, n\}$. Если $|A| \ge 3$ и $|B| \ge 2$, то каждое такое значение периода достигается при нектором автомате $V_q$ и некторой последовательности $\alpha$.

*Доказательство:* 

Пусть $\alpha_1 = \alpha(1)\ldots \alpha(\tau’)$ и $\alpha_2 = \alpha(\tau’ + 1)\ldots \alpha(\tau’ + \tau)$. Тогда $\alpha = \alpha_1 \alpha_2 \alpha_2 \ldots$

У автомата $n$ состояний, следовательно в последовательности $\varphi(q_1, \alpha_1 \alpha_2), \ldots, \varphi(q_1, \alpha_1 \alpha_2^{n + 1})$ существуют одинаковые состояния. Пусть $\varphi(q_1, \alpha_1 \alpha_2^{i_1}) = \varphi(q_1, \alpha_1 \alpha_2^{i_2}) = q, \,\,\,\, i_1 < i_2$. Далее возьмем $\alpha_3 = \alpha_2^{i_2 - i_1}$. $q = \varphi(q_1, \alpha_1 \alpha_2^{i_1}) = \varphi(q_1, \alpha_1 \alpha_2^{i_1} \alpha_3) = \varphi(\varphi(q_1, \alpha_1 \alpha_2^{i_1}), \alpha_3) = \varphi(q, \alpha_3)$.

$\alpha = \alpha_1 \alpha_2^{i_1} \alpha_3 \alpha_3 \ldots$

$$\beta = \overline{\psi}(q_1, \alpha) = \overline{\psi}(q_1, \alpha_1 \alpha_3 \alpha_3 \ldots) = \overline{\psi}(q_1, \alpha_1\alpha_2^{i_1})\overline{\psi}(\varphi(q_1, \alpha_1\alpha_2^{i_1}), \alpha_3 \alpha_3 \ldots)=$$
$$= \overline{\psi}(q_1, \alpha_1\alpha_2^{i_1})\overline{\psi}(q, \alpha_3 \alpha_3 \ldots) = \overline{\psi}(q_1, \alpha_1\alpha_2^{i_1})\overline{\psi}(q, \alpha_3)\overline{\psi}(\varphi(q, \alpha_3), \alpha_3 \alpha_3 \ldots)=$$

Получаем, что $\overline{\psi}(q_1, \alpha)$ периодическая последовательность с длиной периода $|\alpha_3| = (i_2 - i_1)\cdot \tau$, то есть минимальный период $\beta$ равен $\theta \cdot m$, где $\theta \,\,|\,\, \tau$ и $m \in \{1, \ldots, n\}$.

::::

## «Одинаковость» автоматов


:::: {#definition-66}

**Определение:**  Пусть $V = (A, Q, B, \varphi, \psi)$ и $V’ = (A, Q’, B, \varphi’, \psi’)$ -- конечные автоматы, $q \in Q$, $q’ \in Q’$. Если $\forall \alpha \in A^{*} \,\,\,\, \overline{\psi}(q, \alpha) = \overline{\psi’}(q’, \alpha)$, то состояния $q$ и $q’$ *неотличимы* друг от друга.<br><br>Если $\exists \alpha \in A^{*}: \,\,\,\, \overline{\psi}(q, \alpha) \ne \overline{\psi’}(q’, \alpha)$, то состояния $q$ и $q’$ *отличимы* друг от друга *словом* $\alpha$.

::::

:::: {#definition-67}

**Определение:**  Если любые два состояния автомата отличимы, то автомат *приведенного типа*.

::::

:::: {#definition-68}

**Определение:**  Пусть $V = (A, Q, B, \varphi, \psi)$ и $V’ = (A, Q’, B, \varphi’, \psi’)$ -- конечные автоматы. Если $\forall q \in Q \,\,\,\, \exists q’ \in Q’$, такое, что $q$ неотличимо от $q’$ и $\forall q’ \in Q’ \,\,\,\, \exists q \in Q$, такое, что $q$ неотличимо от $q’$, то автоматы $V$ и $V’$ *неотличимы*.

::::

:::: {#definition-69}

**Определение:**  Пусть $V = (A, Q, B, \varphi, \psi)$ и $V’ = (A, Q’, B, \varphi’, \psi’)$ -- конечные автоматы. Если существует биективное отображение $\xi: Q \to Q’$, такое, что $\forall a \in A, q \in Q$ $$\xi(\varphi(q, a)) = \varphi’(\xi(q), a)$$ $$\psi(q, a) = \psi’(\xi(q), a),$$ то автоматы $V$ и $V’$ *изоморфны*.

::::

:::: {#theorem-11}

**Теорема:**  У любого конечного автомата $V$ существует единственный с точностью до изоморфизма автомат приведенного типа неотличимый от $V$.

*Доказательство:*

Разбиваем $Q$ на $Q_1, \ldots, Q_n$ попарно неотличимых состояний. Доказываем, что для $q, q’ \in Q_j \,\,\,\, \varphi(q, a) = \varphi(q’, a) \Rightarrow Q_j = \varphi(Q_i, a)$, следовательно получили отображение $\varphi’: \{Q_1, \ldots, Q_n\}\times A \to \{Q_1, \ldots, Q_n\}$. 

$b = \psi(Q_i, a)$, следовательно получили отображение $\psi’: \{Q_1, \ldots, Q_n\}\times A \to B$.

Далее проверяем, что автомат $(A, \{Q_1, \ldots, Q_n\}, B, \varphi ’, \psi’)$ неотличим от $V$ и приведенный.

Единственность с точностью до изоморфизма. Доказываем, что количество состояний $V$ и $V’$ одинаковы, и говорим, что $\xi: q_i \mapsto q_i’$ $\,\,\,\,\blacksquare$

::::

:::: {#theorem-12}

**Теорема:**  (Мур #1) Если два состояния автомата $V = (A, Q, B, \varphi, \psi)$ отличимы, то существует отличающее их слово длины $|Q| - 1$ и эта оценка неулучшаема.

*Доказательство:* Рассмотрим отношение эквивалентности $\rho_k$ на $Q$. $q_1 \rho_k q_2 \Leftrightarrow \forall \alpha \in A^{*}: \,\,\,\, |\alpha| = k \,\,\,\, \varphi(q_1, \alpha) = \varphi(q_2, \alpha)$.

$Q$ разбивается на классы эквивалентности $R_1, \ldots, R_n$.

Докажем, что в $R_1$ не менее двух состояний. Пусть $q$ и $q’$ неотличимые состояния автомата $V$, то есть существует непустое слово (возьмем такое слово минимальной длины) $\alpha’ a, \,\,\,\, \alpha ’ \in A^{*}, \,\,\,\,a \in A$, которое отличает $q$ и $q’$. Так как длина наименьшая слово $\alpha’ a$ отличает $q$ и $q’$ последней буквой, то есть $\varphi(\varphi(q, \alpha’), a) = \varphi(q, \alpha’ a) \ne \varphi(q’, \alpha’ a) = \varphi(\varphi(q’, \alpha’), a)$. По индукции доказывается, что $|R_i| \le i + 1$.

Очевидно, что $R_k \subset R_{k + 1} \,\,\,\, \forall k$, но, так как состояний конечное количество, в какой-то момент $R_k = R_{k + 1} = \ldots = R$

Получаем, что $|Q| \ge |R_k| \ge k + 1 \Rightarrow k \le |Q| - 1 \,\,\,\,\blacksquare$

::::

**Пример**, показывающий неулучшаемость оценки...

## Распознавание событий конечными автоматами


:::: {#definition-70}

**Определение:**  Пусть $V = (A, Q, B , \varphi, \psi, q)$ -- инициальный конечный автомат. Любое подмножество $A^{*} \setminus \Lambda$ -- *событие*.

::::

:::: {#definition-71}

**Определение:**  Пусть $V = (A, Q, B , \varphi, \psi, q)$ -- инициальный конечный автомат, $B’ \subset B$. Множество $M = \{\alpha \in A^{*} \setminus \Lambda: \,\,\,\,\psi(q, \alpha) \in B’\}$ -- событие, *представимое* автоматом $V$ посредством $B’$.

::::

:::: {#definition-72}

**Определение:**  Пусть $M_1$ и $M_2$ события. Множество $M_1\cdot M_2 = \{\alpha_1 \alpha_2: \,\,\,\, \alpha_1 \in M_1, \alpha_2 \in M_2\}$ -- *произведение событий* $M_1$ и $M_2$.

::::

:::: {#definition-73}

**Определение:**  Пусть $M$ -- событие. Множество $<M> = \{\alpha_1\ldots \alpha_k: \,\,\,\, \alpha_i \in M\}$ -- *итерация события* $M$.

::::

### Простейшие свойства итерации и произведения событий


:::: {#statement-28}

**Утверждение:**  Пусть $M$ -- событие. Тогда

1. $M \cdot \varnothing = \varnothing \cdot M$
2. $<\varnothing> = \varnothing$
3. $<M> = M \cdot <M> \cup M$
4. $<M>\cdot M = M \cdot <M>$

*Доказательство:* $\,\,\,\,\blacksquare$

::::

:::: {#statement-29}

**Утверждение:**  Пусть $X, C, D$ -- события. Тогда $X = XC \cup D \,\,\,\, \Leftrightarrow \,\,\,\, X = D <C> \cup D$.

*Доказательство:* $\not\subset$

::::

### Регулярные события

:::: {#definition-74}

**Определение:**  <br><br>1. События $\varnothing$ и $a \in A$ -- *регулярные*.<br>2. Если $R_1$ и $R_2$ регулярные события, то $R_1 \cdot R_2$, $R_1 \cup R_2$ и $<R_1>$ -- *регулярные* события.

::::

:::: {#statement-30}

**Утверждение:**  Пусть $R_{ij}, \,\,\,\, i \in \{0, \ldots, n\}, \,\,\,\, j \in \{1, \ldots, n\}$ и $X_1, \ldots, X_n$ удовлетворяют системе уравнений:
$$X_1 = X_1 \cdot R_{11} \cup \ldots \cup X_n \cdot R_{n1} \cup R_{01}$$
$$X_2 = X_1 \cdot R_{12} \cup \ldots \cup X_n \cdot R_{n2} \cup R_{02}$$
$$\vdots$$
$$X_n = X_1 \cdot R_{1n} \cup \ldots \cup X_n \cdot R_{nn} \cup R_{0n}$$
Тогда $X_1, \ldots, X_n$ -- регулярные события.

*Доказательство:* Индукция по $n$.

**База:** $n = 1 \Rightarrow X_1 = X_1 \cdot R_{11}\cup R_{01}$ следует из утверждения $\,\,\,\,\blacksquare$

**Шаг:** ну, пооочти очев $\,\,\,\,\blacksquare$

::::

:::: {#statement-31}

**Утверждение:**  События представимые в инициальном конечном автомате -- регулярные.

*Доказательство:*

Пусть $V = (A, Q, B, \varphi, \psi, q_1)$, $Q = \{q_1, \ldots, q_n\}$, $M$ -- событие, представимое посредством $B’$.

$$M_i = \{\alpha \in A^{*}\setminus \Lambda: \,\,\,\, \varphi(q_1, \alpha) = q_i\}$$

$$M_i’ = \{a \in A^{*} (|a| = 1): \,\,\,\, \psi(q_i, a) \in B’\}$$

$$\Downarrow$$

$$M = M_1 M_1’ \cup \ldots \cup M_n M_n’$$

$M_i’$ -- регулярно.

$$R_{ij} = \{a \in A^{*} (|a| = 1): \,\,\,\, \varphi(q_i, a) = q_j\}, \,\,\,\, i, j \in \{1, \ldots, n\}$$

$R_{ij}$ -- регулярно.

$$M_1 = M_1 R_{11} \cup \ldots \cup M_n R_{n1} \cup R_{11}$$
$$\vdots$$
$$M_n = M_n R_{1n} \cup \ldots \cup M_n R_{nn} \cup R_{1n}$$

$$\Downarrow$$

$M_i$ -- регулярно $\,\,\,\,\blacksquare$

::::

## Обобщенные источники


:::: {#definition-75}

**Определение:**  Пусть $A$ -- алфавит. *Обобщенный источник (в алфавите)* $A$ -- это конечный ориентированный граф, каждому ребру которого сопоставлен символ $a \in A$ или пустое слово $\Lambda$, и в котором выбраны начальная вершина $v$ и финальная вершина $w$.

::::

:::: {#definition-76}

**Определение:**  Пусть $G$ -- обобщенный источник. $v_1$ и $v_{n + 1}$ вершины $G$. Последовательность $\pi_{v_1 \to v_{n + 1}}: \,\,\,\, v_1, e_1, \ldots, v_n, e_n, v_{n + 1}$ -- *путь* от вершины $v_1$ к вершине $v_{n + 1}$.<br>$[\pi]$ -- это слово составленное из символов ребер, входящих в путь $\pi$.

::::

:::: {#definition-77}

**Определение:**  Пусть $A$ -- алфавит, $G$ -- обобщенный источник, $\alpha \in A^{*}$, $u$ -- вершина $G$. $\theta(u, \alpha) = \{v \in G: \,\,\,\, \exists \pi_{u \to v}: \,\,\,\, [\pi] = \alpha\}$.

::::

:::: {#definition-78}

**Определение:**  Пусть $A$ -- алфавит, $G$ -- обобщенный источник с начальной вершиной $v$ и финальной вершиной $w$. *Событие* $|G|$, *определяемое источником* $G$ -- это $|G| = \{\alpha \in A^{*}: \,\,\,\, w \in \theta(v, \alpha)\}$. 

::::

:::: {#statement-32}

**Утверждение:**  Если $R$ -- регулярное событие, то существует обобщенный источник $G$, такой, что $|G| = R$.

*Доказательство:* индукция по определению регулярного события с помощью картинок $\,\,\,\,\blacksquare$

::::

:::: {#statement-33}

**Утверждение:**  Пусть $G$ -- обобщенный источник. Тогда $|G|$ представимо.

*Доказательство:*

Пусть $M = \{v_1, \ldots, v_n\}$ -- множество вершин $G$, $v_1$ -- начальная вершина, $v_n$ -- финальная вершина. Пусть $Q = 2^M$ и $\varphi: Q\times A \to Q$ определена так: 

$$\varphi(q, a) = \displaystyle\cup_{v \in q}\theta(v, a)$$
$$\psi(q, a) = \begin{cases}
1, v_n \in \varphi(q, a)\\
0, 
\end{cases}$$

$$\forall \alpha \in A^{*}\setminus \Lambda \,\,\,\, \psi(q, \alpha) = 1 \Leftrightarrow v_n \in \varphi(q, \alpha)$$

Докажем по индукции по длине слова, что $\forall \alpha \in A^{*}\setminus \Lambda$ выполнено:

$$\varphi(\{v_1\}, \alpha) = \theta(v_1, \alpha)$$

**База:** $|\alpha| = 1$ выполнено по определению $\varphi$.

**Шаг:** 

$$\varphi(\{v_1\}, \alpha) = \varphi(\varphi(\{v_1\}, \alpha’), a) = \varphi(\theta(v_1, \alpha’), a) = \displaystyle\bigcup_{v \in \theta(v_1, \alpha’)}\theta(v, a)$$

$$\theta(\{v_1\}, \alpha) = \displaystyle\bigcup_{v \in \theta(v_1, \alpha’)}\theta(v, a) \,\,\,\,\blacksquare$$

::::

:::: {#theorem-13}

**Теорема:**  (Клини) Событие представимо тогда и только тогда, когда оно регулярно.

*Доказательство:* см. $1$ и $2$ $\,\,\,\,\blacksquare$

::::

:::: {#statement-34}

**Утверждение:**  Существуют непредставимые события.

*Доказательство:* Множество всех событий континуально, множество представимых событий счетно $\,\,\,\,\blacksquare$

::::

:::: {#statement-35}

**Утверждение:**  Событие $M$ в алфавите $\{0, 1\}$, состоящее из последовательностей с одинаковым количеством нулей и единиц непредставимо.

*Доказательство:* $\,\,\,\,\blacksquare$

::::

## Структурные автоматы


:::: {#definition-79}

**Определение:**  Пусть $V_q = (\{0, 1\}^n, Q, \{0, 1\}^m, \varphi, \psi, q)$ -- инициальный конечный автомат. Множество всех автоматных функций $f(\alpha) = \overline{\psi}(q, \alpha)$, задаваемых автоматами вида $V_q$ обозначается $P_{\operatorname{авт}}$.

::::

:::: {#definition-80}

**Определение:**  Пусть $f \in P_{\operatorname{авт}}$, $\alpha \in (\{0, 1\}^n)^{*}$(слово, буквы которого -- это последовательности нулей и единиц), $\alpha = \alpha(1)\ldots \alpha(l)$, $\alpha(i) = (\alpha_1(i), \ldots, \alpha_n(i))$ (функция $\alpha_j$ -- это $j$-й элемент буквы). Пусть $\alpha_j = (\alpha_j(1), \ldots, \alpha_j(l))$ (взяли $j$-й элемент каждой буквы слова $\alpha$). Определим функцию $g(\alpha_1, \ldots, \alpha_n) = f(\alpha)$.<br><br> Если $i$-я переменная функции $g$ существенная, то $i$-й вход автомата *существенный*.<br><br>Если функция $\psi_j$(см. канонические уравнения) зависит от $a_i(t)$ фиктивно, то $j$-й выход автомата *зависит* от $i$-ого *с задержкой*. 

::::

:::: {#definition-81}

**Определение:**  <details>
<summary></summary>
Тут будет лажа
</details> Пусть $E$ -- это множество схем-компонент (квадратиков с пометкой). Пусть $\Sigma: E \to \{f_1, \ldots, f_p\} \subset P_{\operatorname{авт}}$ (*сигнатура*).

Схему $E_i$, которой соответствует $f_i = \Sigma(E_i)$, будем обозначать квадратом, в который входит $n \ge 0$ стрелок (количество входов автомата, задаваемого $f_i$) и выходит $m \ge 1$ стрелок (количество выходов автомата, задаваемого $f_i$).

::::

:::: {#definition-82}

**Определение:**

1. Элемент $E_i \subset E$ -- *схема*.

2. Схема -- это штука, полученная при помощи операций:

  a. Переподключения входов и выходов схемы (при переподключении входов важно, чтобы все существенные входы сохранились)
  b. Объединения непересекающихся схем.
  c. Операции обратной связи (вклеивание стрелки ведущей от выхода, зависящего от некоторого входа с задержкой, в этот вход)

::::

:::: {#definition-83}

**Определение:**  Операции $a, b, c$ -- это операции *композиции*.

::::

:::: {#definition-84}

**Определение:**  Множество всех функций, полученных операциями композиции из $F \subset P_{\operatorname{авт}}$, обозначается $[F]$.

::::

:::: {#definition-85}

**Определение:**  $F \subset P_{\operatorname{авт}}$ *полная*, если $[F] = P_{\operatorname{авт}}$

::::

### Пример полной относительно композиций системы


:::: {#definition-86}

**Определение:**  Если функция $f \in P_{\operatorname{авт}}$ pеализуется схемой в сигнатуре, построенной только при помощи операций переобозначения входов и выходов, объединения схем и их последовательного соединения, то $f$ получена *суперпозициями* из функций $\{f_1,\ldots, f_p\}$ данной сигнатуры. Множество всех функций, полученных операциями суперпозиции из функций множества $F \subset P_{\operatorname{авт}}$, обозначается $[F]_c$. Система $F \subset P_{\operatorname{авт}}$ *полна* относительно суперпозиций, если $[F]_c = P_{\operatorname{авт}}$.

::::

:::: {#theorem-14}

**Теорема:**  В $P_{\operatorname{авт}}$ не существует конечной полной относительно суперпозиций системы функций.

*Доказательство:*

::::

## Однородные структуры


:::: {#definition-87}

**Определение:**  *Однородная структура* -- это $\sigma = (\mathbb{Z}^k, E_n, V, \varphi)$, где <br><br> $\mathbb{Z}^k$ -- множество $k$-мерных целочисленных векторов (координаты клеток дискретного пространства (все нормальные люди используют $\mathbb{Z}^2$, но математик должен быть ненормальным, особенно, в 01:00))<br><br> $E_n = \{0, \ldots, n - 1\}$ -- множество кодов состояний (каждая клетка в каждый момент времени находится в каком-то состоянии) <br><br> $V = \{\alpha_1, \ldots, \alpha_{h - 1}: \,\,\,\, \alpha_i \in \mathbb{Z}^k, \,\,\,\, \alpha_i \ne \alpha_j, \,\,\,\, i \ne j\}$ -- *шаблон соседства клетки* (кого видит клетка)<br><br> $\varphi: (E_n)^h \to E_n$ -- *функция изменения состояния клетки*(*локальная функция переходов*) (зависит от $h$ переменных -- состояний соседей клетки) и $\varphi(0, \ldots, 0) = 0$.

::::

:::: {#definition-88}

**Определение:**  Пусть $\sigma$ -- однородная структура. *Состояние однородной структуры* $\sigma$ -- это функция $f: \mathbb{Z}^k \to E_n$.

::::

:::: {#definition-89}

**Определение:**  Пусть $\sigma$ -- однородная структура и задано некоторое множество ее состояний $F$. *Основная (глобальная) функция переходов однородной структуры* -- это $\Phi: F \to F$, такая, что $$\Phi(f)(\alpha) = \varphi(f(\alpha), f(\alpha + \alpha_1), \ldots, f(\alpha + \alpha_{h - 1})), \,\,\,\, f \in F, \,\,\,\, \alpha \in \mathbb{Z}^k$$

::::

:::: {#definition-90}

**Определение:**  *Поведение однородной структуры* -- это последовательность ее состояний $f_0, f_1, f_2, \ldots$, такая, что $f_{i + 1} = \Phi(f_i)\,\,\,\, \forall i$.

::::

:::: {#definition-91}

**Определение:**  *Конфигурация однородной структуры* -- это такое ее состояние, при котором только конечное число клеток имеют ненулевое значение.

::::

:::: {#statement-36}

**Утверждение:**  При переходе к новому состоянию конфигурация однородной структуры остается конфигурацией.

*Доказательство:* $\,\,\,\,\blacksquare$

::::

<center><canvas id="life-canvas"></canvas></center>

:::: {#definition-92}

**Определение:**  Однородная структура $\sigma = (\mathbb{Z}^2, E_k, V, \varphi)$, у которой $V(\alpha)$ квадрат со стороной $2\cdot m + 1$ с центром в $\alpha, \,\,\,\, \alpha \in \mathbb{Z}^2$ -- *квадратная*.

::::

:::: {#definition-93}

**Определение:**  Пусть $K \subset \mathbb{Z}^2$ -- квадрат. $V(K) = \displaystyle\bigcup_{\alpha \in K}V(\alpha)$ -- *окрестность квадрата*.

::::

:::: {#statement-37}

**Утверждение:**  Окрестность квадрата -- квадрат.

*Доказательство:* $\,\,\,\,\blacksquare$

::::

:::: {#definition-94}

**Определение:**  *Состояние окрестности квадрата* -- это функция $f: V(K) \to E_k$. Функция $g = \Phi_K(f)$ -- это ограничение глобальной функции переходов, определенной на состояниях окрестности квадрата на сам квадрат.<br><br>Состояние квадрата -- *конфигурация*.<br><br>Если конфигурация квадрата не принадлежит множеству значений $\Phi_K$, то она *неконструируемая*.

::::

:::: {#definition-95}

**Определение:**  Пусть $f_1$ и $f_2$ -- конфигурации квадрата $V(V(K))$. Если <br><br>1. ${f_1}_{|K} \ne {f_2}_{|K}$<br>2. ${f_1}_{|V(V(K))\setminus K} = {f_2}_{|V(V(K))\setminus K}$<br>3. $\Phi_{V(K)}(f_1)_{|K} = \Phi_{V(K)}(f_2)_{|K}$, то конфигурации $f_1$ и $f_2$ -- *взаимностираемые*.

::::

:::: {#theorem-15}

**Теорема:**  (Мур #100500) Пусть $\sigma = (\mathbb{Z}^2, E_k, V, \varphi)$ -- квадратная однородная структура, где $V(\alpha)$ -- квадрат со стороной $2\cdot m + 1$. Тогда существование в $\sigma$ взаимностираемых конфигураций $\Leftrightarrow$ существуют неконструируемые конфигурации.

*Доказательство:*

Пусть $f_1$ и $f_2$ взаимностираемые конфигурации на квадрате $K$. 

Пусть $K’ = V(V(K))$. Определим на $K’$ отношение эквивалентности состояний. $f_1 \sim f_2 \Leftrightarrow f_1$ и $f_2$ взаимностираемые на квадрате $K$ или $f_1$ и $f_2$ совпадают. 

Пусть длина стороны $K’$ -- это $l$. Тогда множество состояний $K’$ равно $k^{l^2}$. Но по условию существует хотя бы один класс эквивалентности, в котором $\ge 2$ элемента, следовательно мощность множества классов эквивалентности не превосходит $k^{l^2} - 1$.

Пусть $N \in \mathbb{N}$. Рассмотрим квадрат $\tilde{K}$ с длиной стороны $l N$, то есть решетку $N$ на $N$ из квадратов $K’$.

$\tilde{K}$ окрестность некторого квадата $\hat{K}$ с длиной стороны - $l M - 2 m$.

Пусть $\tilde{f}_1$ и $\tilde{f}_2$ состояния квадрата $\tilde{K}$, такие, что их сужения на каждый из подквадратов $K’$ эквивалентны. Докажем, что $\Phi_{\hat{K}}(\tilde{f}_1) = \Phi_{\hat{K}}(\tilde{f}_2)$. Положим, что очевидно.

Следовательно, число состояний $\Phi_{\hat{K}}$ не превосходит $\left(k^{l^2} - 1\right)^{N^2}$, а общее число состояний $\hat{K}$ -- это $k^{(l N - 2 m)^2}$.

Рассмотрим отношение числа состояний, которые могут быть получены, к числу возможных состояний 
$$\eta = \frac{\left(k^{l^2} - 1\right)^{N^2}}{k^{(l N - 2 m)^2}} = \left(\frac{k^{l^2} - 1}{k^{\frac{(l N - 2 m)^2}{N^2}}}\right)^{N^2}$$

Существует $N$, такое, что $\eta < 1 \,\,\,\,\blacksquare$

::::

![](img/cg.png){#inv}
![](img/cp.png){#inv}
![](img/cy.png){#inv}
![](img/dhs2.png){#inv}
![](img/purple_heart.png){#inv}
![](img/red_heart.png){#inv}

<script>
    var requestAnimFrame = (function(){
    return window.requestAnimationFrame    ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame    ||
        window.oRequestAnimationFrame      ||
        window.msRequestAnimationFrame     ||
        function(callback){
            window.setTimeout(callback, 1000 / 60);
        };
})();

const Resources = {
    loaded: 0,
    total: 0,
    images: {},
    onComplete: null,

    load(urls) {
        this.total = urls.length;
        this.loaded = 0;

        for (let i = 0; i < urls.length; i++) {
            const url = urls[i];
            const image = new Image();

            image.addEventListener('load', () => {
                this.loaded++;
                this.images[url] = image;

                if (this.loaded === this.total && typeof this.onComplete === 'function') {
                    this.onComplete();
                }
            });

            image.addEventListener('error', () => {
                console.error(`Error loading image: ${url}`);

                this.loaded++;

                if (this.loaded === this.total && typeof this.onComplete === 'function') {
                    this.onComplete();
                }
            });

            image.src = url;
        }
    },

    onReady(callback) {
        if (typeof callback === 'function') {
            this.onComplete = callback;

            if (this.loaded === this.total) {
                this.onComplete();
            }
        }
    },

    get(url) {
        return this.images[url] || null;
    }
};

const canvas = document.getElementById("main-canvas");
const ctx = canvas.getContext("2d");

const comp_table_canvas = document.getElementById('table-canvas');
const comp_table_ctx = comp_table_canvas.getContext('2d');

const diam_table_canvas = document.getElementById('diam-table-canvas');
const diam_table_ctx = diam_table_canvas.getContext('2d');

const heart_table_canvas = document.getElementById('heart-table-canvas');
const heart_table_ctx = heart_table_canvas.getContext('2d');

const diagram_canvas = document.getElementById('diagram-canvas');
const diagram_ctx = diagram_canvas.getContext('2d');

const computers_table = [
  ['img/cp.png', 'img/cy.png', 'img/cg.png'],
];

const hearts_table = [["red_heart", "purple_heart"]];
const diamonds_table = [["purple", "cyan", "green", "red"],
                        ["orange", "pink", "yellow", "grey"]]

const margin = 30;
const space = 30;

const width = 500;
const height = 300;
const table_height = 300;
canvas.width = width;
canvas.height = height;

comp_table_canvas.width = width;
diam_table_canvas.width = width;
heart_table_canvas.width = width;

diagram_canvas.width = width;
diagram_canvas.height = width;

const boxWidth = 129;
const boxHeight = 138;
const boxX = width / 2 - boxWidth / 2;
const boxY = height / 2 - boxHeight / 2;

const leftSpriteX = boxX - 50;
const leftSpriteY = boxY + boxHeight / 2;
const rightSpriteX = boxX + boxWidth + 50;
const rightSpriteY = boxY + boxHeight / 2;

const sprites = {
    "purple": [0, 0],
    "cyan": [0, 1],
    "green": [0, 2],
    "red": [0, 3],
    "orange": [0, 4],
    "pink": [1, 0],
    "blue": [1, 1],
    "yellow": [1, 2],
    "grey": [1, 4],
    "red_heart": [2, 1],
    "purple_heart": [2, 2],
};

let a = "red_heart";
const states = ["purple", "cyan", "green", "red", "orange", "pink", "yellow", "grey"];
const computers = ["img/cy.png", "img/cg.png", "img/cp.png"];

let dashOffset = 0;
let index = 0;
const dashSpeed = 1;
let spriteWidth = 80;
let spriteHeight = 80;


function main() {
    drawBox();
    requestAnimFrame(main);
};


function init() {
    drawTable(computers_table, 50, 70, 20, drawComp, comp_table_ctx, comp_table_canvas);
    drawTable(diamonds_table, 50, 50, 20, drawSprite, diam_table_ctx, diam_table_canvas);
    drawTable(hearts_table, 50, 100, 50, drawSprite, heart_table_ctx, heart_table_canvas);
    drawDiagram();
    main();
}

const resources = Object.create(Resources);

resources.load([
    'img/cy.png',
    'img/cg.png',
    'img/cp.png',
    'img/dhs2.png'
]);
resources.onReady(init);

function drawDiagram() {
    const comp1 = resources.get("img/cy.png");
    const comp2 = resources.get("img/cg.png");
    const comp3 = resources.get("img/cp.png");

    const x1 = width / 2 - comp1.width / 2;
    const y1 = 50;

    const x2 = width / 5 - comp2.width / 2;
    const y2 = width - y1 - comp2.height;

    const x3 = 4 * width / 5 - comp2.width / 2;
    const y3 = width - y1 - comp2.height;

    diagram_ctx.drawImage(comp1, x1, y1, boxWidth, boxHeight);
    diagram_ctx.drawImage(comp2, x2, y2, boxWidth, boxHeight);
    diagram_ctx.drawImage(comp3, x3, y3, boxWidth, boxHeight);

}


function drawTable(table, margin_top, margin_side, space, draw_function, ctx, canvas) {
    const n_cols = table[0].length;
    const n_rows = table.length;
    const cellWidth = (width - 2 * margin_side - space * (n_cols - 1)) / n_cols;
    const cellHeight = cellWidth;
    canvas.height = 2 * margin_top + n_rows * cellHeight;
    for (let row = 0; row < n_rows; row++) {
        for (let col = 0; col < n_cols; col++) {

            const x = margin_side + col * (cellWidth + space);
            const y = margin_top + row * cellHeight;

            draw_function(table[row][col], x, y, cellWidth, cellHeight, ctx);
        }
    }
}

function drawComp(img_url, x, y, cellWidth, cellHeight, ctx) {
    ctx.drawImage(resources.get(img_url), x, y, cellWidth, cellHeight);
}

function drawSprite(name, x, y, cellWidth, cellHeight, ctx) {
    const sprite = sprites[name];
    const image = resources.get('img/dhs2.png');

    ctx.drawImage(
        image,
        sprite[1] * spriteWidth,
        sprite[0] * spriteHeight,
        spriteWidth,
        spriteHeight,
        x,
        y,
        cellWidth,
        cellHeight
    );
}

function drawBox() {
    const sprite = sprites[states[index % states.length]];
    const x = sprite[1];
    const y = sprite[0];
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    dashOffset += dashSpeed;
    if (dashOffset > 10)
    {
        dashOffset = 0;
    }

    ctx.beginPath();
    ctx.setLineDash([5, 5]);
    ctx.lineDashOffset = -dashOffset;
    ctx.moveTo(leftSpriteX - spriteWidth / 2, leftSpriteY);
    ctx.lineTo(boxX, boxY + boxHeight / 2);
    ctx.lineTo(rightSpriteX + spriteWidth / 2, rightSpriteY);
    ctx.strokeStyle = "black";
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.drawImage(resources.get(computers[index % computers.length]), 
        boxX, 
        boxY, 
        boxWidth, 
        boxHeight
    );
    
   
    ctx.drawImage(
        resources.get('img/dhs2.png'),
        1 * spriteWidth,
        2 * spriteHeight,
        spriteWidth,
        spriteHeight,
        leftSpriteX - spriteWidth,
        leftSpriteY - spriteHeight / 2,
        spriteWidth,
        spriteHeight
    );

    ctx.drawImage(
        resources.get('img/dhs2.png'),
        x * spriteWidth,
        y * spriteHeight,
        spriteWidth,
        spriteHeight,
        rightSpriteX,
        rightSpriteY - spriteHeight / 2,
        spriteWidth,
        spriteHeight
    );
}

const slider = document.getElementById("slider");

function handleSliderChange() {
    index = parseInt(slider.value) - 1;
}

const button = document.getElementById('state_button');
const iconImage = document.getElementById('iconImage');
const images = ['img/red_heart.png', 'img/purple_heart.png']; // Add paths to your different icon images

let currentIndex = 0;

button.addEventListener('click', function() {
  currentIndex = (currentIndex + 1) % images.length; // Cycle through the images
  iconImage.src = images[currentIndex]; // Change the image source
});

slider.addEventListener("input", handleSliderChange);
</script>

<script>
    class Cell
{
    static width = 10;
    static height = 10;

    constructor (context, gridX, gridY)
    {
        this.context = context;

        this.gridX = gridX;
        this.gridY = gridY;

        this.alive = Math.random() > 0.99;
    }

    draw() {
        if (this.alive)
        {
          this.context.fillStyle = '#7bc99a';
          this.context.fillRect(this.gridX * Cell.width, this.gridY * Cell.height, Cell.width, Cell.height);
        }
    }
}

class GameWorld {

    static numColumns = 75;
    static numRows = 40;

    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.context = this.canvas.getContext('2d');
        this.canvas.width = 500;
        this.canvas.height = 500;

        this.gameObjects = [];

        this.createGrid();

        window.requestAnimationFrame(() => this.gameLoop());
    }

    createGrid()
    {
        for (let y = 0; y < GameWorld.numRows; y++) {
            for (let x = 0; x < GameWorld.numColumns; x++) {
                this.gameObjects.push(new Cell(this.context, x, y));
            }
        }
    }

    isAlive(x, y)
    {
        if (x < 0 || x >= GameWorld.numColumns || y < 0 || y >= GameWorld.numRows){
            return false;
        }

        return this.gameObjects[this.gridToIndex(x, y)].alive ? 1 : 0;
    }

    gridToIndex(x, y){
        return x + (y * GameWorld.numColumns);
    }

    checkSurrounding ()
    {
        for (let x = 0; x < GameWorld.numColumns; x++) {
            for (let y = 0; y < GameWorld.numRows; y++) {

                let numAlive = this.isAlive(x - 1, y - 1) + this.isAlive(x, y - 1) + this.isAlive(x + 1, y - 1) + this.isAlive(x - 1, y) + this.isAlive(x + 1, y) + this.isAlive(x - 1, y + 1) + this.isAlive(x, y + 1) + this.isAlive(x + 1, y + 1);
                let centerIndex = this.gridToIndex(x, y);

                if (numAlive % 2 === 1)
                {
                  this.gameObjects[centerIndex].nextAlive = true;
                }
                else
                {
                  this.gameObjects[centerIndex].nextAlive = false;
                }

                /*if (numAlive == 2)
                {
                    this.gameObjects[centerIndex].nextAlive = this.gameObjects[centerIndex].alive;
                }
                else if (numAlive == 3)
                {
                    this.gameObjects[centerIndex].nextAlive = true;
                }
                else
                {
                    this.gameObjects[centerIndex].nextAlive = false;
                }*/
            }
        }

        for (let i = 0; i < this.gameObjects.length; i++) {
            this.gameObjects[i].alive = this.gameObjects[i].nextAlive;
        }
    }

    gameLoop() {
        this.checkSurrounding();

        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);

        //this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)

        for (let i = 0; i < this.gameObjects.length; i++) {
            this.gameObjects[i].draw();
        }

        setTimeout( () => {
            window.requestAnimationFrame(() => this.gameLoop());
        }, 500)
    }
}

window.onload = () => {
  let gameWorld = new GameWorld('life-canvas');
}
</script>